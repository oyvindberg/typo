/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package customtypes

import adventureworks.Text
import java.sql.ResultSet
import java.sql.Types
import org.postgresql.util.PGInterval
import typo.dsl.ParameterMetaData
import zio.jdbc.JdbcDecoder
import zio.jdbc.JdbcEncoder
import zio.jdbc.SqlFragment.Setter
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** Interval type in PostgreSQL */
case class TypoInterval(years: Int, months: Int, days: Int, hours: Int, minutes: Int, seconds: Double)

object TypoInterval {
  implicit lazy val arrayJdbcDecoder: JdbcDecoder[Array[TypoInterval]] = JdbcDecoder[Array[TypoInterval]]((rs: ResultSet) => (i: Int) =>
    rs.getArray(i) match {
      case null => null
      case arr => arr.getArray.asInstanceOf[Array[AnyRef]].map(x => TypoInterval(x.asInstanceOf[PGInterval].getYears, x.asInstanceOf[PGInterval].getMonths, x.asInstanceOf[PGInterval].getDays, x.asInstanceOf[PGInterval].getHours, x.asInstanceOf[PGInterval].getMinutes, x.asInstanceOf[PGInterval].getSeconds))
    },
    "scala.Array[org.postgresql.util.PGInterval]"
  )
  implicit lazy val arrayJdbcEncoder: JdbcEncoder[Array[TypoInterval]] = JdbcEncoder.singleParamEncoder(arraySetter)
  implicit lazy val arraySetter: Setter[Array[TypoInterval]] = Setter.forSqlType((ps, i, v) =>
    ps.setArray(
      i,
      ps.getConnection.createArrayOf(
        "interval",
        v.map { vv =>
          new PGInterval(vv.years, vv.months, vv.days, vv.hours, vv.minutes, vv.seconds)
        }
      )
    ),
    Types.ARRAY
  )
  implicit lazy val jdbcDecoder: JdbcDecoder[TypoInterval] = JdbcDecoder[TypoInterval](
    (rs: ResultSet) => (i: Int) => {
      val v = rs.getObject(i)
      if (v eq null) null else TypoInterval(v.asInstanceOf[PGInterval].getYears, v.asInstanceOf[PGInterval].getMonths, v.asInstanceOf[PGInterval].getDays, v.asInstanceOf[PGInterval].getHours, v.asInstanceOf[PGInterval].getMinutes, v.asInstanceOf[PGInterval].getSeconds)
    },
    "org.postgresql.util.PGInterval"
  )
  implicit lazy val jdbcEncoder: JdbcEncoder[TypoInterval] = JdbcEncoder.singleParamEncoder(setter)
  implicit lazy val jsonDecoder: JsonDecoder[TypoInterval] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val years = jsonObj.get("years").toRight("Missing field 'years'").flatMap(_.as(JsonDecoder.int))
    val months = jsonObj.get("months").toRight("Missing field 'months'").flatMap(_.as(JsonDecoder.int))
    val days = jsonObj.get("days").toRight("Missing field 'days'").flatMap(_.as(JsonDecoder.int))
    val hours = jsonObj.get("hours").toRight("Missing field 'hours'").flatMap(_.as(JsonDecoder.int))
    val minutes = jsonObj.get("minutes").toRight("Missing field 'minutes'").flatMap(_.as(JsonDecoder.int))
    val seconds = jsonObj.get("seconds").toRight("Missing field 'seconds'").flatMap(_.as(JsonDecoder.double))
    if (years.isRight && months.isRight && days.isRight && hours.isRight && minutes.isRight && seconds.isRight)
      Right(TypoInterval(years = years.toOption.get, months = months.toOption.get, days = days.toOption.get, hours = hours.toOption.get, minutes = minutes.toOption.get, seconds = seconds.toOption.get))
    else Left(List[Either[String, Any]](years, months, days, hours, minutes, seconds).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[TypoInterval] = new JsonEncoder[TypoInterval] {
    override def unsafeEncode(a: TypoInterval, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""years":""")
      JsonEncoder.int.unsafeEncode(a.years, indent, out)
      out.write(",")
      out.write(""""months":""")
      JsonEncoder.int.unsafeEncode(a.months, indent, out)
      out.write(",")
      out.write(""""days":""")
      JsonEncoder.int.unsafeEncode(a.days, indent, out)
      out.write(",")
      out.write(""""hours":""")
      JsonEncoder.int.unsafeEncode(a.hours, indent, out)
      out.write(",")
      out.write(""""minutes":""")
      JsonEncoder.int.unsafeEncode(a.minutes, indent, out)
      out.write(",")
      out.write(""""seconds":""")
      JsonEncoder.double.unsafeEncode(a.seconds, indent, out)
      out.write("}")
    }
  }
  implicit lazy val ordering: Ordering[TypoInterval] = Ordering.by(x => (x.years, x.months, x.days, x.hours, x.minutes, x.seconds))
  implicit lazy val parameterMetadata: ParameterMetaData[TypoInterval] = ParameterMetaData.instance[TypoInterval]("interval", Types.OTHER)
  implicit lazy val setter: Setter[TypoInterval] = Setter.other(
    (ps, i, v) => {
      ps.setObject(
        i,
        new PGInterval(v.years, v.months, v.days, v.hours, v.minutes, v.seconds)
      )
    },
    "interval"
  )
  implicit lazy val text: Text[TypoInterval] = new Text[TypoInterval] {
    override def unsafeEncode(v: TypoInterval, sb: StringBuilder) = Text.stringInstance.unsafeEncode(s"P${v.years}Y${v.months}M${v.days}DT${v.hours}H${v.minutes}M${v.seconds}S", sb)
    override def unsafeArrayEncode(v: TypoInterval, sb: StringBuilder) = Text.stringInstance.unsafeArrayEncode(s"P${v.years}Y${v.months}M${v.days}DT${v.hours}H${v.minutes}M${v.seconds}S", sb)
  }
}
