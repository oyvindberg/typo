/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package customtypes

import scala.math.Numeric
import typo.dsl.Bijection
import zio.json.JsonDecoder
import zio.json.JsonEncoder

/** Short primitive */
case class TypoShort(value: Short)

object TypoShort {
  implicit object numeric extends Numeric[TypoShort] {
      override def compare(x: TypoShort, y: TypoShort): Int = java.lang.Short.compare(x.value, y.value)
      override def plus(x: TypoShort, y: TypoShort): TypoShort = TypoShort((x.value + y.value).toShort)
      override def minus(x: TypoShort, y: TypoShort): TypoShort = TypoShort((x.value - y.value).toShort)
      override def times(x: TypoShort, y: TypoShort): TypoShort = TypoShort((x.value * y.value).toShort)
      override def negate(x: TypoShort): TypoShort = TypoShort((-x.value).toShort)
      override def fromInt(x: Int): TypoShort = TypoShort(x.toShort)
      override def toInt(x: TypoShort): Int = x.toInt
      override def toLong(x: TypoShort): Long = x.toLong
      override def toFloat(x: TypoShort): Float = x.toFloat
      override def toDouble(x: TypoShort): Double = x.toDouble
      def parseString(str: String): Option[TypoShort] = (str, Option.empty[TypoShort])._2 // sorry mac, this was too much trouble to implement for 2.12
    }
  implicit lazy val bijection: Bijection[TypoShort, Short] = Bijection[TypoShort, Short](_.value)(TypoShort.apply)
  implicit lazy val decoder: JsonDecoder[TypoShort] = JsonDecoder[Short].map(TypoShort.apply)
  implicit lazy val encoder: JsonEncoder[TypoShort] = JsonEncoder[Short].contramap(_.value)
  implicit lazy val ordering: Ordering[TypoShort] = Ordering.by(_.value)
}
