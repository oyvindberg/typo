/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package person

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.frontpage.address.AddressId
import java.sql.ResultSet
import zio.jdbc.JdbcDecoder
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** Table: frontpage.person
    Primary key: id */
case class PersonRow(
  /** Default: gen_random_uuid() */
  id: PersonId,
  name: String,
  /** Points to [[address.AddressRow.id]] */
  addressId: Option[AddressId],
  /** Default: now() */
  createdAt: Option[TypoLocalDateTime]
){
   def toUnsavedRow(id: Defaulted[PersonId], createdAt: Defaulted[Option[TypoLocalDateTime]] = Defaulted.Provided(this.createdAt)): PersonRowUnsaved =
     PersonRowUnsaved(name, addressId, id, createdAt)
 }

object PersonRow {
  implicit lazy val jdbcDecoder: JdbcDecoder[PersonRow] = new JdbcDecoder[PersonRow] {
    override def unsafeDecode(columIndex: Int, rs: ResultSet): (Int, PersonRow) =
      columIndex + 3 ->
        PersonRow(
          id = PersonId.jdbcDecoder.unsafeDecode(columIndex + 0, rs)._2,
          name = JdbcDecoder.stringDecoder.unsafeDecode(columIndex + 1, rs)._2,
          addressId = JdbcDecoder.optionDecoder(AddressId.jdbcDecoder).unsafeDecode(columIndex + 2, rs)._2,
          createdAt = JdbcDecoder.optionDecoder(TypoLocalDateTime.jdbcDecoder).unsafeDecode(columIndex + 3, rs)._2
        )
  }
  implicit lazy val jsonDecoder: JsonDecoder[PersonRow] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val id = jsonObj.get("id").toRight("Missing field 'id'").flatMap(_.as(PersonId.jsonDecoder))
    val name = jsonObj.get("name").toRight("Missing field 'name'").flatMap(_.as(JsonDecoder.string))
    val addressId = jsonObj.get("address_id").fold[Either[String, Option[AddressId]]](Right(None))(_.as(JsonDecoder.option(using AddressId.jsonDecoder)))
    val createdAt = jsonObj.get("created_at").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    if (id.isRight && name.isRight && addressId.isRight && createdAt.isRight)
      Right(PersonRow(id = id.toOption.get, name = name.toOption.get, addressId = addressId.toOption.get, createdAt = createdAt.toOption.get))
    else Left(List[Either[String, Any]](id, name, addressId, createdAt).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[PersonRow] = new JsonEncoder[PersonRow] {
    override def unsafeEncode(a: PersonRow, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""id":""")
      PersonId.jsonEncoder.unsafeEncode(a.id, indent, out)
      out.write(",")
      out.write(""""name":""")
      JsonEncoder.string.unsafeEncode(a.name, indent, out)
      out.write(",")
      out.write(""""address_id":""")
      JsonEncoder.option(using AddressId.jsonEncoder).unsafeEncode(a.addressId, indent, out)
      out.write(",")
      out.write(""""created_at":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.createdAt, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[PersonRow] = Text.instance[PersonRow]{ (row, sb) =>
    PersonId.text.unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Text.stringInstance.unsafeEncode(row.name, sb)
    sb.append(Text.DELIMETER)
    Text.option(AddressId.text).unsafeEncode(row.addressId, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.createdAt, sb)
  }
}
