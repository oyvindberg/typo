/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package product

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoJsonb
import adventureworks.customtypes.TypoLocalDateTime
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** This class corresponds to a row in table `frontpage.product` which has not been persisted yet */
case class ProductRowUnsaved(
  name: String,
  price: BigDecimal,
  lastRestocked: Option[TypoLocalDateTime],
  /** Default: gen_random_uuid() */
  id: Defaulted[ProductId] = Defaulted.UseDefault,
  /** Default: true */
  inStock: Defaulted[Option[Boolean]] = Defaulted.UseDefault,
  /** Default: 0 */
  quantity: Defaulted[Option[Int]] = Defaulted.UseDefault,
  /** Default: now() */
  lastModified: Defaulted[Option[TypoLocalDateTime]] = Defaulted.UseDefault,
  /** Default: '{}'::text[] */
  tags: Defaulted[Option[Array[String]]] = Defaulted.UseDefault,
  /** Default: '{}'::integer[] */
  categories: Defaulted[Option[Array[Int]]] = Defaulted.UseDefault,
  /** Default: '{}'::numeric[] */
  prices: Defaulted[Option[Array[BigDecimal]]] = Defaulted.UseDefault,
  /** Default: '{}'::jsonb[] */
  attributes: Defaulted[Option[Array[TypoJsonb]]] = Defaulted.UseDefault
) {
  def toRow(idDefault: => ProductId, inStockDefault: => Option[Boolean], quantityDefault: => Option[Int], lastModifiedDefault: => Option[TypoLocalDateTime], tagsDefault: => Option[Array[String]], categoriesDefault: => Option[Array[Int]], pricesDefault: => Option[Array[BigDecimal]], attributesDefault: => Option[Array[TypoJsonb]]): ProductRow =
    ProductRow(
      name = name,
      price = price,
      lastRestocked = lastRestocked,
      id = id match {
             case Defaulted.UseDefault => idDefault
             case Defaulted.Provided(value) => value
           },
      inStock = inStock match {
                  case Defaulted.UseDefault => inStockDefault
                  case Defaulted.Provided(value) => value
                },
      quantity = quantity match {
                   case Defaulted.UseDefault => quantityDefault
                   case Defaulted.Provided(value) => value
                 },
      lastModified = lastModified match {
                       case Defaulted.UseDefault => lastModifiedDefault
                       case Defaulted.Provided(value) => value
                     },
      tags = tags match {
               case Defaulted.UseDefault => tagsDefault
               case Defaulted.Provided(value) => value
             },
      categories = categories match {
                     case Defaulted.UseDefault => categoriesDefault
                     case Defaulted.Provided(value) => value
                   },
      prices = prices match {
                 case Defaulted.UseDefault => pricesDefault
                 case Defaulted.Provided(value) => value
               },
      attributes = attributes match {
                     case Defaulted.UseDefault => attributesDefault
                     case Defaulted.Provided(value) => value
                   }
    )
}
object ProductRowUnsaved {
  implicit lazy val jsonDecoder: JsonDecoder[ProductRowUnsaved] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val name = jsonObj.get("name").toRight("Missing field 'name'").flatMap(_.as(JsonDecoder.string))
    val price = jsonObj.get("price").toRight("Missing field 'price'").flatMap(_.as(JsonDecoder.scalaBigDecimal))
    val lastRestocked = jsonObj.get("last_restocked").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    val id = jsonObj.get("id").toRight("Missing field 'id'").flatMap(_.as(Defaulted.jsonDecoder(ProductId.jsonDecoder)))
    val inStock = jsonObj.get("in_stock").toRight("Missing field 'in_stock'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using JsonDecoder.boolean))))
    val quantity = jsonObj.get("quantity").toRight("Missing field 'quantity'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using JsonDecoder.int))))
    val lastModified = jsonObj.get("last_modified").toRight("Missing field 'last_modified'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder))))
    val tags = jsonObj.get("tags").toRight("Missing field 'tags'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using JsonDecoder.array[String](using JsonDecoder.string, implicitly)))))
    val categories = jsonObj.get("categories").toRight("Missing field 'categories'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using JsonDecoder.array[Int](using JsonDecoder.int, implicitly)))))
    val prices = jsonObj.get("prices").toRight("Missing field 'prices'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using JsonDecoder.array[BigDecimal](using JsonDecoder.scalaBigDecimal, implicitly)))))
    val attributes = jsonObj.get("attributes").toRight("Missing field 'attributes'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using JsonDecoder.array[TypoJsonb](using TypoJsonb.jsonDecoder, implicitly)))))
    if (name.isRight && price.isRight && lastRestocked.isRight && id.isRight && inStock.isRight && quantity.isRight && lastModified.isRight && tags.isRight && categories.isRight && prices.isRight && attributes.isRight)
      Right(ProductRowUnsaved(name = name.toOption.get, price = price.toOption.get, lastRestocked = lastRestocked.toOption.get, id = id.toOption.get, inStock = inStock.toOption.get, quantity = quantity.toOption.get, lastModified = lastModified.toOption.get, tags = tags.toOption.get, categories = categories.toOption.get, prices = prices.toOption.get, attributes = attributes.toOption.get))
    else Left(List[Either[String, Any]](name, price, lastRestocked, id, inStock, quantity, lastModified, tags, categories, prices, attributes).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[ProductRowUnsaved] = new JsonEncoder[ProductRowUnsaved] {
    override def unsafeEncode(a: ProductRowUnsaved, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""name":""")
      JsonEncoder.string.unsafeEncode(a.name, indent, out)
      out.write(",")
      out.write(""""price":""")
      JsonEncoder.scalaBigDecimal.unsafeEncode(a.price, indent, out)
      out.write(",")
      out.write(""""last_restocked":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.lastRestocked, indent, out)
      out.write(",")
      out.write(""""id":""")
      Defaulted.jsonEncoder(ProductId.jsonEncoder).unsafeEncode(a.id, indent, out)
      out.write(",")
      out.write(""""in_stock":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using JsonEncoder.boolean)).unsafeEncode(a.inStock, indent, out)
      out.write(",")
      out.write(""""quantity":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using JsonEncoder.int)).unsafeEncode(a.quantity, indent, out)
      out.write(",")
      out.write(""""last_modified":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using TypoLocalDateTime.jsonEncoder)).unsafeEncode(a.lastModified, indent, out)
      out.write(",")
      out.write(""""tags":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using JsonEncoder.array[String](using JsonEncoder.string, implicitly))).unsafeEncode(a.tags, indent, out)
      out.write(",")
      out.write(""""categories":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using JsonEncoder.array[Int](using JsonEncoder.int, implicitly))).unsafeEncode(a.categories, indent, out)
      out.write(",")
      out.write(""""prices":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using JsonEncoder.array[BigDecimal](using JsonEncoder.scalaBigDecimal, implicitly))).unsafeEncode(a.prices, indent, out)
      out.write(",")
      out.write(""""attributes":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using JsonEncoder.array[TypoJsonb](using TypoJsonb.jsonEncoder, implicitly))).unsafeEncode(a.attributes, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[ProductRowUnsaved] = Text.instance[ProductRowUnsaved]{ (row, sb) =>
    Text.stringInstance.unsafeEncode(row.name, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.price, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.lastRestocked, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(ProductId.text).unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text.booleanInstance)).unsafeEncode(row.inStock, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text.intInstance)).unsafeEncode(row.quantity, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(TypoLocalDateTime.text)).unsafeEncode(row.lastModified, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text[Array[String]])).unsafeEncode(row.tags, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text[Array[Int]])).unsafeEncode(row.categories, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text[Array[BigDecimal]])).unsafeEncode(row.prices, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text.iterableInstance[Array, TypoJsonb](TypoJsonb.text, implicitly))).unsafeEncode(row.attributes, sb)
  }
}
