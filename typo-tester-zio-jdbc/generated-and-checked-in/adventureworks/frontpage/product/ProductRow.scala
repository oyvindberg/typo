/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package product

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoJsonb
import adventureworks.customtypes.TypoLocalDateTime
import java.sql.ResultSet
import zio.jdbc.JdbcDecoder
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** Table: frontpage.product
    Primary key: id */
case class ProductRow(
  /** Default: gen_random_uuid() */
  id: ProductId,
  name: String,
  price: BigDecimal,
  /** Default: true */
  inStock: Option[Boolean],
  /** Default: 0 */
  quantity: Option[Int],
  lastRestocked: Option[TypoLocalDateTime],
  /** Default: now() */
  lastModified: Option[TypoLocalDateTime],
  /** Default: '{}'::text[] */
  tags: Option[Array[String]],
  /** Default: '{}'::integer[] */
  categories: Option[Array[Int]],
  /** Default: '{}'::numeric[] */
  prices: Option[Array[BigDecimal]],
  /** Default: '{}'::jsonb[] */
  attributes: Option[Array[TypoJsonb]]
){
   def toUnsavedRow(id: Defaulted[ProductId], inStock: Defaulted[Option[Boolean]] = Defaulted.Provided(this.inStock), quantity: Defaulted[Option[Int]] = Defaulted.Provided(this.quantity), lastModified: Defaulted[Option[TypoLocalDateTime]] = Defaulted.Provided(this.lastModified), tags: Defaulted[Option[Array[String]]] = Defaulted.Provided(this.tags), categories: Defaulted[Option[Array[Int]]] = Defaulted.Provided(this.categories), prices: Defaulted[Option[Array[BigDecimal]]] = Defaulted.Provided(this.prices), attributes: Defaulted[Option[Array[TypoJsonb]]] = Defaulted.Provided(this.attributes)): ProductRowUnsaved =
     ProductRowUnsaved(name, price, lastRestocked, id, inStock, quantity, lastModified, tags, categories, prices, attributes)
 }

object ProductRow {
  implicit lazy val jdbcDecoder: JdbcDecoder[ProductRow] = new JdbcDecoder[ProductRow] {
    override def unsafeDecode(columIndex: Int, rs: ResultSet): (Int, ProductRow) =
      columIndex + 10 ->
        ProductRow(
          id = ProductId.jdbcDecoder.unsafeDecode(columIndex + 0, rs)._2,
          name = JdbcDecoder.stringDecoder.unsafeDecode(columIndex + 1, rs)._2,
          price = JdbcDecoder.bigDecimalDecoderScala.unsafeDecode(columIndex + 2, rs)._2,
          inStock = JdbcDecoder.optionDecoder(JdbcDecoder.booleanDecoder).unsafeDecode(columIndex + 3, rs)._2,
          quantity = JdbcDecoder.optionDecoder(JdbcDecoder.intDecoder).unsafeDecode(columIndex + 4, rs)._2,
          lastRestocked = JdbcDecoder.optionDecoder(TypoLocalDateTime.jdbcDecoder).unsafeDecode(columIndex + 5, rs)._2,
          lastModified = JdbcDecoder.optionDecoder(TypoLocalDateTime.jdbcDecoder).unsafeDecode(columIndex + 6, rs)._2,
          tags = JdbcDecoder.optionDecoder(adventureworks.StringArrayDecoder).unsafeDecode(columIndex + 7, rs)._2,
          categories = JdbcDecoder.optionDecoder(adventureworks.IntArrayDecoder).unsafeDecode(columIndex + 8, rs)._2,
          prices = JdbcDecoder.optionDecoder(adventureworks.ScalaBigDecimalArrayDecoder).unsafeDecode(columIndex + 9, rs)._2,
          attributes = JdbcDecoder.optionDecoder(JdbcDecoder[Array[TypoJsonb]]).unsafeDecode(columIndex + 10, rs)._2
        )
  }
  implicit lazy val jsonDecoder: JsonDecoder[ProductRow] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val id = jsonObj.get("id").toRight("Missing field 'id'").flatMap(_.as(ProductId.jsonDecoder))
    val name = jsonObj.get("name").toRight("Missing field 'name'").flatMap(_.as(JsonDecoder.string))
    val price = jsonObj.get("price").toRight("Missing field 'price'").flatMap(_.as(JsonDecoder.scalaBigDecimal))
    val inStock = jsonObj.get("in_stock").fold[Either[String, Option[Boolean]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.boolean)))
    val quantity = jsonObj.get("quantity").fold[Either[String, Option[Int]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.int)))
    val lastRestocked = jsonObj.get("last_restocked").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    val lastModified = jsonObj.get("last_modified").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    val tags = jsonObj.get("tags").fold[Either[String, Option[Array[String]]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.array[String](using JsonDecoder.string, implicitly))))
    val categories = jsonObj.get("categories").fold[Either[String, Option[Array[Int]]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.array[Int](using JsonDecoder.int, implicitly))))
    val prices = jsonObj.get("prices").fold[Either[String, Option[Array[BigDecimal]]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.array[BigDecimal](using JsonDecoder.scalaBigDecimal, implicitly))))
    val attributes = jsonObj.get("attributes").fold[Either[String, Option[Array[TypoJsonb]]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.array[TypoJsonb](using TypoJsonb.jsonDecoder, implicitly))))
    if (id.isRight && name.isRight && price.isRight && inStock.isRight && quantity.isRight && lastRestocked.isRight && lastModified.isRight && tags.isRight && categories.isRight && prices.isRight && attributes.isRight)
      Right(ProductRow(id = id.toOption.get, name = name.toOption.get, price = price.toOption.get, inStock = inStock.toOption.get, quantity = quantity.toOption.get, lastRestocked = lastRestocked.toOption.get, lastModified = lastModified.toOption.get, tags = tags.toOption.get, categories = categories.toOption.get, prices = prices.toOption.get, attributes = attributes.toOption.get))
    else Left(List[Either[String, Any]](id, name, price, inStock, quantity, lastRestocked, lastModified, tags, categories, prices, attributes).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[ProductRow] = new JsonEncoder[ProductRow] {
    override def unsafeEncode(a: ProductRow, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""id":""")
      ProductId.jsonEncoder.unsafeEncode(a.id, indent, out)
      out.write(",")
      out.write(""""name":""")
      JsonEncoder.string.unsafeEncode(a.name, indent, out)
      out.write(",")
      out.write(""""price":""")
      JsonEncoder.scalaBigDecimal.unsafeEncode(a.price, indent, out)
      out.write(",")
      out.write(""""in_stock":""")
      JsonEncoder.option(using JsonEncoder.boolean).unsafeEncode(a.inStock, indent, out)
      out.write(",")
      out.write(""""quantity":""")
      JsonEncoder.option(using JsonEncoder.int).unsafeEncode(a.quantity, indent, out)
      out.write(",")
      out.write(""""last_restocked":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.lastRestocked, indent, out)
      out.write(",")
      out.write(""""last_modified":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.lastModified, indent, out)
      out.write(",")
      out.write(""""tags":""")
      JsonEncoder.option(using JsonEncoder.array[String](using JsonEncoder.string, implicitly)).unsafeEncode(a.tags, indent, out)
      out.write(",")
      out.write(""""categories":""")
      JsonEncoder.option(using JsonEncoder.array[Int](using JsonEncoder.int, implicitly)).unsafeEncode(a.categories, indent, out)
      out.write(",")
      out.write(""""prices":""")
      JsonEncoder.option(using JsonEncoder.array[BigDecimal](using JsonEncoder.scalaBigDecimal, implicitly)).unsafeEncode(a.prices, indent, out)
      out.write(",")
      out.write(""""attributes":""")
      JsonEncoder.option(using JsonEncoder.array[TypoJsonb](using TypoJsonb.jsonEncoder, implicitly)).unsafeEncode(a.attributes, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[ProductRow] = Text.instance[ProductRow]{ (row, sb) =>
    ProductId.text.unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Text.stringInstance.unsafeEncode(row.name, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.price, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.booleanInstance).unsafeEncode(row.inStock, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.intInstance).unsafeEncode(row.quantity, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.lastRestocked, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.lastModified, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text[Array[String]]).unsafeEncode(row.tags, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text[Array[Int]]).unsafeEncode(row.categories, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text[Array[BigDecimal]]).unsafeEncode(row.prices, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.iterableInstance[Array, TypoJsonb](TypoJsonb.text, implicitly)).unsafeEncode(row.attributes, sb)
  }
}
