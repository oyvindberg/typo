/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package order

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.frontpage.product.ProductId
import adventureworks.frontpage.user.UserId
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** This class corresponds to a row in table `frontpage.order` which has not been persisted yet */
case class OrderRowUnsaved(
  /** Points to [[user.UserRow.id]] */
  userId: Option[UserId],
  /** Points to [[product.ProductRow.id]] */
  productId: Option[ProductId],
  total: BigDecimal,
  shippedAt: Option[TypoLocalDateTime],
  /** Default: gen_random_uuid() */
  id: Defaulted[OrderId] = Defaulted.UseDefault,
  /** Default: 'pending'::frontpage.order_status */
  status: Defaulted[Option[OrderStatus]] = Defaulted.UseDefault,
  /** Default: now() */
  createdAt: Defaulted[Option[TypoLocalDateTime]] = Defaulted.UseDefault
) {
  def toRow(idDefault: => OrderId, statusDefault: => Option[OrderStatus], createdAtDefault: => Option[TypoLocalDateTime]): OrderRow =
    OrderRow(
      userId = userId,
      productId = productId,
      total = total,
      shippedAt = shippedAt,
      id = id match {
             case Defaulted.UseDefault => idDefault
             case Defaulted.Provided(value) => value
           },
      status = status match {
                 case Defaulted.UseDefault => statusDefault
                 case Defaulted.Provided(value) => value
               },
      createdAt = createdAt match {
                    case Defaulted.UseDefault => createdAtDefault
                    case Defaulted.Provided(value) => value
                  }
    )
}
object OrderRowUnsaved {
  implicit lazy val jsonDecoder: JsonDecoder[OrderRowUnsaved] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val userId = jsonObj.get("user_id").fold[Either[String, Option[UserId]]](Right(None))(_.as(JsonDecoder.option(using UserId.jsonDecoder)))
    val productId = jsonObj.get("product_id").fold[Either[String, Option[ProductId]]](Right(None))(_.as(JsonDecoder.option(using ProductId.jsonDecoder)))
    val total = jsonObj.get("total").toRight("Missing field 'total'").flatMap(_.as(JsonDecoder.scalaBigDecimal))
    val shippedAt = jsonObj.get("shipped_at").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    val id = jsonObj.get("id").toRight("Missing field 'id'").flatMap(_.as(Defaulted.jsonDecoder(OrderId.jsonDecoder)))
    val status = jsonObj.get("status").toRight("Missing field 'status'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using OrderStatus.jsonDecoder))))
    val createdAt = jsonObj.get("created_at").toRight("Missing field 'created_at'").flatMap(_.as(Defaulted.jsonDecoder(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder))))
    if (userId.isRight && productId.isRight && total.isRight && shippedAt.isRight && id.isRight && status.isRight && createdAt.isRight)
      Right(OrderRowUnsaved(userId = userId.toOption.get, productId = productId.toOption.get, total = total.toOption.get, shippedAt = shippedAt.toOption.get, id = id.toOption.get, status = status.toOption.get, createdAt = createdAt.toOption.get))
    else Left(List[Either[String, Any]](userId, productId, total, shippedAt, id, status, createdAt).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[OrderRowUnsaved] = new JsonEncoder[OrderRowUnsaved] {
    override def unsafeEncode(a: OrderRowUnsaved, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""user_id":""")
      JsonEncoder.option(using UserId.jsonEncoder).unsafeEncode(a.userId, indent, out)
      out.write(",")
      out.write(""""product_id":""")
      JsonEncoder.option(using ProductId.jsonEncoder).unsafeEncode(a.productId, indent, out)
      out.write(",")
      out.write(""""total":""")
      JsonEncoder.scalaBigDecimal.unsafeEncode(a.total, indent, out)
      out.write(",")
      out.write(""""shipped_at":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.shippedAt, indent, out)
      out.write(",")
      out.write(""""id":""")
      Defaulted.jsonEncoder(OrderId.jsonEncoder).unsafeEncode(a.id, indent, out)
      out.write(",")
      out.write(""""status":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using OrderStatus.jsonEncoder)).unsafeEncode(a.status, indent, out)
      out.write(",")
      out.write(""""created_at":""")
      Defaulted.jsonEncoder(JsonEncoder.option(using TypoLocalDateTime.jsonEncoder)).unsafeEncode(a.createdAt, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[OrderRowUnsaved] = Text.instance[OrderRowUnsaved]{ (row, sb) =>
    Text.option(UserId.text).unsafeEncode(row.userId, sb)
    sb.append(Text.DELIMETER)
    Text.option(ProductId.text).unsafeEncode(row.productId, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.total, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.shippedAt, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(OrderId.text).unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(OrderStatus.text)).unsafeEncode(row.status, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(TypoLocalDateTime.text)).unsafeEncode(row.createdAt, sb)
  }
}
