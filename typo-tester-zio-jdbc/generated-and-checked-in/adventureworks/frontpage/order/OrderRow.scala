/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package order

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.frontpage.product.ProductId
import adventureworks.frontpage.user.UserId
import java.sql.ResultSet
import zio.jdbc.JdbcDecoder
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** Table: frontpage.order
    Primary key: id */
case class OrderRow(
  /** Default: gen_random_uuid() */
  id: OrderId,
  /** Points to [[user.UserRow.id]] */
  userId: Option[UserId],
  /** Points to [[product.ProductRow.id]] */
  productId: Option[ProductId],
  /** Default: 'pending'::frontpage.order_status */
  status: Option[OrderStatus],
  total: BigDecimal,
  /** Default: now() */
  createdAt: Option[TypoLocalDateTime],
  shippedAt: Option[TypoLocalDateTime]
){
   def toUnsavedRow(id: Defaulted[OrderId], status: Defaulted[Option[OrderStatus]] = Defaulted.Provided(this.status), createdAt: Defaulted[Option[TypoLocalDateTime]] = Defaulted.Provided(this.createdAt)): OrderRowUnsaved =
     OrderRowUnsaved(userId, productId, total, shippedAt, id, status, createdAt)
 }

object OrderRow {
  implicit lazy val jdbcDecoder: JdbcDecoder[OrderRow] = new JdbcDecoder[OrderRow] {
    override def unsafeDecode(columIndex: Int, rs: ResultSet): (Int, OrderRow) =
      columIndex + 6 ->
        OrderRow(
          id = OrderId.jdbcDecoder.unsafeDecode(columIndex + 0, rs)._2,
          userId = JdbcDecoder.optionDecoder(UserId.jdbcDecoder).unsafeDecode(columIndex + 1, rs)._2,
          productId = JdbcDecoder.optionDecoder(ProductId.jdbcDecoder).unsafeDecode(columIndex + 2, rs)._2,
          status = JdbcDecoder.optionDecoder(OrderStatus.jdbcDecoder).unsafeDecode(columIndex + 3, rs)._2,
          total = JdbcDecoder.bigDecimalDecoderScala.unsafeDecode(columIndex + 4, rs)._2,
          createdAt = JdbcDecoder.optionDecoder(TypoLocalDateTime.jdbcDecoder).unsafeDecode(columIndex + 5, rs)._2,
          shippedAt = JdbcDecoder.optionDecoder(TypoLocalDateTime.jdbcDecoder).unsafeDecode(columIndex + 6, rs)._2
        )
  }
  implicit lazy val jsonDecoder: JsonDecoder[OrderRow] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val id = jsonObj.get("id").toRight("Missing field 'id'").flatMap(_.as(OrderId.jsonDecoder))
    val userId = jsonObj.get("user_id").fold[Either[String, Option[UserId]]](Right(None))(_.as(JsonDecoder.option(using UserId.jsonDecoder)))
    val productId = jsonObj.get("product_id").fold[Either[String, Option[ProductId]]](Right(None))(_.as(JsonDecoder.option(using ProductId.jsonDecoder)))
    val status = jsonObj.get("status").fold[Either[String, Option[OrderStatus]]](Right(None))(_.as(JsonDecoder.option(using OrderStatus.jsonDecoder)))
    val total = jsonObj.get("total").toRight("Missing field 'total'").flatMap(_.as(JsonDecoder.scalaBigDecimal))
    val createdAt = jsonObj.get("created_at").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    val shippedAt = jsonObj.get("shipped_at").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    if (id.isRight && userId.isRight && productId.isRight && status.isRight && total.isRight && createdAt.isRight && shippedAt.isRight)
      Right(OrderRow(id = id.toOption.get, userId = userId.toOption.get, productId = productId.toOption.get, status = status.toOption.get, total = total.toOption.get, createdAt = createdAt.toOption.get, shippedAt = shippedAt.toOption.get))
    else Left(List[Either[String, Any]](id, userId, productId, status, total, createdAt, shippedAt).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[OrderRow] = new JsonEncoder[OrderRow] {
    override def unsafeEncode(a: OrderRow, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""id":""")
      OrderId.jsonEncoder.unsafeEncode(a.id, indent, out)
      out.write(",")
      out.write(""""user_id":""")
      JsonEncoder.option(using UserId.jsonEncoder).unsafeEncode(a.userId, indent, out)
      out.write(",")
      out.write(""""product_id":""")
      JsonEncoder.option(using ProductId.jsonEncoder).unsafeEncode(a.productId, indent, out)
      out.write(",")
      out.write(""""status":""")
      JsonEncoder.option(using OrderStatus.jsonEncoder).unsafeEncode(a.status, indent, out)
      out.write(",")
      out.write(""""total":""")
      JsonEncoder.scalaBigDecimal.unsafeEncode(a.total, indent, out)
      out.write(",")
      out.write(""""created_at":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.createdAt, indent, out)
      out.write(",")
      out.write(""""shipped_at":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.shippedAt, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[OrderRow] = Text.instance[OrderRow]{ (row, sb) =>
    OrderId.text.unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Text.option(UserId.text).unsafeEncode(row.userId, sb)
    sb.append(Text.DELIMETER)
    Text.option(ProductId.text).unsafeEncode(row.productId, sb)
    sb.append(Text.DELIMETER)
    Text.option(OrderStatus.text).unsafeEncode(row.status, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.total, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.createdAt, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.shippedAt, sb)
  }
}
