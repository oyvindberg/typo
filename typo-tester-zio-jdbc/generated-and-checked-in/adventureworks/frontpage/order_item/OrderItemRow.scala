/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package order_item

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.frontpage.order.OrderId
import adventureworks.frontpage.product.ProductId
import java.sql.ResultSet
import zio.jdbc.JdbcDecoder
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** Table: frontpage.order_item
    Primary key: id */
case class OrderItemRow(
  /** Default: gen_random_uuid() */
  id: OrderItemId,
  /** Points to [[order.OrderRow.id]] */
  orderId: Option[OrderId],
  /** Points to [[product.ProductRow.id]] */
  productId: Option[ProductId],
  quantity: Int,
  price: BigDecimal,
  shippedAt: Option[TypoLocalDateTime]
){
   def toUnsavedRow(id: Defaulted[OrderItemId]): OrderItemRowUnsaved =
     OrderItemRowUnsaved(orderId, productId, quantity, price, shippedAt, id)
 }

object OrderItemRow {
  implicit lazy val jdbcDecoder: JdbcDecoder[OrderItemRow] = new JdbcDecoder[OrderItemRow] {
    override def unsafeDecode(columIndex: Int, rs: ResultSet): (Int, OrderItemRow) =
      columIndex + 5 ->
        OrderItemRow(
          id = OrderItemId.jdbcDecoder.unsafeDecode(columIndex + 0, rs)._2,
          orderId = JdbcDecoder.optionDecoder(OrderId.jdbcDecoder).unsafeDecode(columIndex + 1, rs)._2,
          productId = JdbcDecoder.optionDecoder(ProductId.jdbcDecoder).unsafeDecode(columIndex + 2, rs)._2,
          quantity = JdbcDecoder.intDecoder.unsafeDecode(columIndex + 3, rs)._2,
          price = JdbcDecoder.bigDecimalDecoderScala.unsafeDecode(columIndex + 4, rs)._2,
          shippedAt = JdbcDecoder.optionDecoder(TypoLocalDateTime.jdbcDecoder).unsafeDecode(columIndex + 5, rs)._2
        )
  }
  implicit lazy val jsonDecoder: JsonDecoder[OrderItemRow] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val id = jsonObj.get("id").toRight("Missing field 'id'").flatMap(_.as(OrderItemId.jsonDecoder))
    val orderId = jsonObj.get("order_id").fold[Either[String, Option[OrderId]]](Right(None))(_.as(JsonDecoder.option(using OrderId.jsonDecoder)))
    val productId = jsonObj.get("product_id").fold[Either[String, Option[ProductId]]](Right(None))(_.as(JsonDecoder.option(using ProductId.jsonDecoder)))
    val quantity = jsonObj.get("quantity").toRight("Missing field 'quantity'").flatMap(_.as(JsonDecoder.int))
    val price = jsonObj.get("price").toRight("Missing field 'price'").flatMap(_.as(JsonDecoder.scalaBigDecimal))
    val shippedAt = jsonObj.get("shipped_at").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    if (id.isRight && orderId.isRight && productId.isRight && quantity.isRight && price.isRight && shippedAt.isRight)
      Right(OrderItemRow(id = id.toOption.get, orderId = orderId.toOption.get, productId = productId.toOption.get, quantity = quantity.toOption.get, price = price.toOption.get, shippedAt = shippedAt.toOption.get))
    else Left(List[Either[String, Any]](id, orderId, productId, quantity, price, shippedAt).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[OrderItemRow] = new JsonEncoder[OrderItemRow] {
    override def unsafeEncode(a: OrderItemRow, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""id":""")
      OrderItemId.jsonEncoder.unsafeEncode(a.id, indent, out)
      out.write(",")
      out.write(""""order_id":""")
      JsonEncoder.option(using OrderId.jsonEncoder).unsafeEncode(a.orderId, indent, out)
      out.write(",")
      out.write(""""product_id":""")
      JsonEncoder.option(using ProductId.jsonEncoder).unsafeEncode(a.productId, indent, out)
      out.write(",")
      out.write(""""quantity":""")
      JsonEncoder.int.unsafeEncode(a.quantity, indent, out)
      out.write(",")
      out.write(""""price":""")
      JsonEncoder.scalaBigDecimal.unsafeEncode(a.price, indent, out)
      out.write(",")
      out.write(""""shipped_at":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.shippedAt, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[OrderItemRow] = Text.instance[OrderItemRow]{ (row, sb) =>
    OrderItemId.text.unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Text.option(OrderId.text).unsafeEncode(row.orderId, sb)
    sb.append(Text.DELIMETER)
    Text.option(ProductId.text).unsafeEncode(row.productId, sb)
    sb.append(Text.DELIMETER)
    Text.intInstance.unsafeEncode(row.quantity, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.price, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.shippedAt, sb)
  }
}
