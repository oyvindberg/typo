/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package purchasing
package productvendor

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.sql.ResultSet
import zio.jdbc.JdbcDecoder
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** Table: purchasing.productvendor
    Cross-reference table mapping vendors with the products they supply.
    Composite primary key: productid, businessentityid */
case class ProductvendorRow(
  /** Primary key. Foreign key to Product.ProductID.
      Points to [[production.product.ProductRow.productid]] */
  productid: ProductId,
  /** Primary key. Foreign key to Vendor.BusinessEntityID.
      Points to [[vendor.VendorRow.businessentityid]] */
  businessentityid: BusinessentityId,
  /** The average span of time (in days) between placing an order with the vendor and receiving the purchased product.
      Constraint CK_ProductVendor_AverageLeadTime affecting columns averageleadtime: ((averageleadtime >= 1)) */
  averageleadtime: Int,
  /** The vendor's usual selling price.
      Constraint CK_ProductVendor_StandardPrice affecting columns standardprice: ((standardprice > 0.00)) */
  standardprice: BigDecimal,
  /** The selling price when last purchased.
      Constraint CK_ProductVendor_LastReceiptCost affecting columns lastreceiptcost: ((lastreceiptcost > 0.00)) */
  lastreceiptcost: Option[BigDecimal],
  /** Date the product was last received by the vendor. */
  lastreceiptdate: Option[TypoLocalDateTime],
  /** The maximum quantity that should be ordered.
      Constraint CK_ProductVendor_MinOrderQty affecting columns minorderqty: ((minorderqty >= 1)) */
  minorderqty: Int,
  /** The minimum quantity that should be ordered.
      Constraint CK_ProductVendor_MaxOrderQty affecting columns maxorderqty: ((maxorderqty >= 1)) */
  maxorderqty: Int,
  /** The quantity currently on order.
      Constraint CK_ProductVendor_OnOrderQty affecting columns onorderqty: ((onorderqty >= 0)) */
  onorderqty: Option[Int],
  /** The product's unit of measure.
      Points to [[production.unitmeasure.UnitmeasureRow.unitmeasurecode]] */
  unitmeasurecode: UnitmeasureId,
  /** Default: now() */
  modifieddate: TypoLocalDateTime
){
   val compositeId: ProductvendorId = ProductvendorId(productid, businessentityid)
   def toUnsavedRow(modifieddate: Defaulted[TypoLocalDateTime] = Defaulted.Provided(this.modifieddate)): ProductvendorRowUnsaved =
     ProductvendorRowUnsaved(productid, businessentityid, averageleadtime, standardprice, lastreceiptcost, lastreceiptdate, minorderqty, maxorderqty, onorderqty, unitmeasurecode, modifieddate)
 }

object ProductvendorRow {
  def apply(compositeId: ProductvendorId, averageleadtime: Int, standardprice: BigDecimal, lastreceiptcost: Option[BigDecimal], lastreceiptdate: Option[TypoLocalDateTime], minorderqty: Int, maxorderqty: Int, onorderqty: Option[Int], unitmeasurecode: UnitmeasureId, modifieddate: TypoLocalDateTime) =
    new ProductvendorRow(compositeId.productid, compositeId.businessentityid, averageleadtime, standardprice, lastreceiptcost, lastreceiptdate, minorderqty, maxorderqty, onorderqty, unitmeasurecode, modifieddate)
  implicit lazy val jdbcDecoder: JdbcDecoder[ProductvendorRow] = new JdbcDecoder[ProductvendorRow] {
    override def unsafeDecode(columIndex: Int, rs: ResultSet): (Int, ProductvendorRow) =
      columIndex + 10 ->
        ProductvendorRow(
          productid = ProductId.jdbcDecoder.unsafeDecode(columIndex + 0, rs)._2,
          businessentityid = BusinessentityId.jdbcDecoder.unsafeDecode(columIndex + 1, rs)._2,
          averageleadtime = JdbcDecoder.intDecoder.unsafeDecode(columIndex + 2, rs)._2,
          standardprice = JdbcDecoder.bigDecimalDecoderScala.unsafeDecode(columIndex + 3, rs)._2,
          lastreceiptcost = JdbcDecoder.optionDecoder(JdbcDecoder.bigDecimalDecoderScala).unsafeDecode(columIndex + 4, rs)._2,
          lastreceiptdate = JdbcDecoder.optionDecoder(TypoLocalDateTime.jdbcDecoder).unsafeDecode(columIndex + 5, rs)._2,
          minorderqty = JdbcDecoder.intDecoder.unsafeDecode(columIndex + 6, rs)._2,
          maxorderqty = JdbcDecoder.intDecoder.unsafeDecode(columIndex + 7, rs)._2,
          onorderqty = JdbcDecoder.optionDecoder(JdbcDecoder.intDecoder).unsafeDecode(columIndex + 8, rs)._2,
          unitmeasurecode = UnitmeasureId.jdbcDecoder.unsafeDecode(columIndex + 9, rs)._2,
          modifieddate = TypoLocalDateTime.jdbcDecoder.unsafeDecode(columIndex + 10, rs)._2
        )
  }
  implicit lazy val jsonDecoder: JsonDecoder[ProductvendorRow] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val productid = jsonObj.get("productid").toRight("Missing field 'productid'").flatMap(_.as(ProductId.jsonDecoder))
    val businessentityid = jsonObj.get("businessentityid").toRight("Missing field 'businessentityid'").flatMap(_.as(BusinessentityId.jsonDecoder))
    val averageleadtime = jsonObj.get("averageleadtime").toRight("Missing field 'averageleadtime'").flatMap(_.as(JsonDecoder.int))
    val standardprice = jsonObj.get("standardprice").toRight("Missing field 'standardprice'").flatMap(_.as(JsonDecoder.scalaBigDecimal))
    val lastreceiptcost = jsonObj.get("lastreceiptcost").fold[Either[String, Option[BigDecimal]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.scalaBigDecimal)))
    val lastreceiptdate = jsonObj.get("lastreceiptdate").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    val minorderqty = jsonObj.get("minorderqty").toRight("Missing field 'minorderqty'").flatMap(_.as(JsonDecoder.int))
    val maxorderqty = jsonObj.get("maxorderqty").toRight("Missing field 'maxorderqty'").flatMap(_.as(JsonDecoder.int))
    val onorderqty = jsonObj.get("onorderqty").fold[Either[String, Option[Int]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.int)))
    val unitmeasurecode = jsonObj.get("unitmeasurecode").toRight("Missing field 'unitmeasurecode'").flatMap(_.as(UnitmeasureId.jsonDecoder))
    val modifieddate = jsonObj.get("modifieddate").toRight("Missing field 'modifieddate'").flatMap(_.as(TypoLocalDateTime.jsonDecoder))
    if (productid.isRight && businessentityid.isRight && averageleadtime.isRight && standardprice.isRight && lastreceiptcost.isRight && lastreceiptdate.isRight && minorderqty.isRight && maxorderqty.isRight && onorderqty.isRight && unitmeasurecode.isRight && modifieddate.isRight)
      Right(ProductvendorRow(productid = productid.toOption.get, businessentityid = businessentityid.toOption.get, averageleadtime = averageleadtime.toOption.get, standardprice = standardprice.toOption.get, lastreceiptcost = lastreceiptcost.toOption.get, lastreceiptdate = lastreceiptdate.toOption.get, minorderqty = minorderqty.toOption.get, maxorderqty = maxorderqty.toOption.get, onorderqty = onorderqty.toOption.get, unitmeasurecode = unitmeasurecode.toOption.get, modifieddate = modifieddate.toOption.get))
    else Left(List[Either[String, Any]](productid, businessentityid, averageleadtime, standardprice, lastreceiptcost, lastreceiptdate, minorderqty, maxorderqty, onorderqty, unitmeasurecode, modifieddate).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[ProductvendorRow] = new JsonEncoder[ProductvendorRow] {
    override def unsafeEncode(a: ProductvendorRow, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""productid":""")
      ProductId.jsonEncoder.unsafeEncode(a.productid, indent, out)
      out.write(",")
      out.write(""""businessentityid":""")
      BusinessentityId.jsonEncoder.unsafeEncode(a.businessentityid, indent, out)
      out.write(",")
      out.write(""""averageleadtime":""")
      JsonEncoder.int.unsafeEncode(a.averageleadtime, indent, out)
      out.write(",")
      out.write(""""standardprice":""")
      JsonEncoder.scalaBigDecimal.unsafeEncode(a.standardprice, indent, out)
      out.write(",")
      out.write(""""lastreceiptcost":""")
      JsonEncoder.option(using JsonEncoder.scalaBigDecimal).unsafeEncode(a.lastreceiptcost, indent, out)
      out.write(",")
      out.write(""""lastreceiptdate":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.lastreceiptdate, indent, out)
      out.write(",")
      out.write(""""minorderqty":""")
      JsonEncoder.int.unsafeEncode(a.minorderqty, indent, out)
      out.write(",")
      out.write(""""maxorderqty":""")
      JsonEncoder.int.unsafeEncode(a.maxorderqty, indent, out)
      out.write(",")
      out.write(""""onorderqty":""")
      JsonEncoder.option(using JsonEncoder.int).unsafeEncode(a.onorderqty, indent, out)
      out.write(",")
      out.write(""""unitmeasurecode":""")
      UnitmeasureId.jsonEncoder.unsafeEncode(a.unitmeasurecode, indent, out)
      out.write(",")
      out.write(""""modifieddate":""")
      TypoLocalDateTime.jsonEncoder.unsafeEncode(a.modifieddate, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[ProductvendorRow] = Text.instance[ProductvendorRow]{ (row, sb) =>
    ProductId.text.unsafeEncode(row.productid, sb)
    sb.append(Text.DELIMETER)
    BusinessentityId.text.unsafeEncode(row.businessentityid, sb)
    sb.append(Text.DELIMETER)
    Text.intInstance.unsafeEncode(row.averageleadtime, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.standardprice, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.bigDecimalInstance).unsafeEncode(row.lastreceiptcost, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.lastreceiptdate, sb)
    sb.append(Text.DELIMETER)
    Text.intInstance.unsafeEncode(row.minorderqty, sb)
    sb.append(Text.DELIMETER)
    Text.intInstance.unsafeEncode(row.maxorderqty, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.intInstance).unsafeEncode(row.onorderqty, sb)
    sb.append(Text.DELIMETER)
    UnitmeasureId.text.unsafeEncode(row.unitmeasurecode, sb)
    sb.append(Text.DELIMETER)
    TypoLocalDateTime.text.unsafeEncode(row.modifieddate, sb)
  }
}
