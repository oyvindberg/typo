/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package purchasing
package productvendor

import adventureworks.Text
import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** This class corresponds to a row in table `purchasing.productvendor` which has not been persisted yet */
case class ProductvendorRowUnsaved(
  /** Primary key. Foreign key to Product.ProductID.
      Points to [[production.product.ProductRow.productid]] */
  productid: ProductId,
  /** Primary key. Foreign key to Vendor.BusinessEntityID.
      Points to [[vendor.VendorRow.businessentityid]] */
  businessentityid: BusinessentityId,
  /** The average span of time (in days) between placing an order with the vendor and receiving the purchased product.
      Constraint CK_ProductVendor_AverageLeadTime affecting columns averageleadtime:  ((averageleadtime >= 1)) */
  averageleadtime: Int,
  /** The vendor's usual selling price.
      Constraint CK_ProductVendor_StandardPrice affecting columns standardprice:  ((standardprice > 0.00)) */
  standardprice: BigDecimal,
  /** The selling price when last purchased.
      Constraint CK_ProductVendor_LastReceiptCost affecting columns lastreceiptcost:  ((lastreceiptcost > 0.00)) */
  lastreceiptcost: Option[BigDecimal],
  /** Date the product was last received by the vendor. */
  lastreceiptdate: Option[TypoLocalDateTime],
  /** The maximum quantity that should be ordered.
      Constraint CK_ProductVendor_MinOrderQty affecting columns minorderqty:  ((minorderqty >= 1)) */
  minorderqty: Int,
  /** The minimum quantity that should be ordered.
      Constraint CK_ProductVendor_MaxOrderQty affecting columns maxorderqty:  ((maxorderqty >= 1)) */
  maxorderqty: Int,
  /** The quantity currently on order.
      Constraint CK_ProductVendor_OnOrderQty affecting columns onorderqty:  ((onorderqty >= 0)) */
  onorderqty: Option[Int],
  /** The product's unit of measure.
      Points to [[production.unitmeasure.UnitmeasureRow.unitmeasurecode]] */
  unitmeasurecode: UnitmeasureId,
  /** Default: now() */
  modifieddate: Defaulted[TypoLocalDateTime] = Defaulted.UseDefault
) {
  def toRow(modifieddateDefault: => TypoLocalDateTime): ProductvendorRow =
    ProductvendorRow(
      productid = productid,
      businessentityid = businessentityid,
      averageleadtime = averageleadtime,
      standardprice = standardprice,
      lastreceiptcost = lastreceiptcost,
      lastreceiptdate = lastreceiptdate,
      minorderqty = minorderqty,
      maxorderqty = maxorderqty,
      onorderqty = onorderqty,
      unitmeasurecode = unitmeasurecode,
      modifieddate = modifieddate match {
                       case Defaulted.UseDefault => modifieddateDefault
                       case Defaulted.Provided(value) => value
                     }
    )
}
object ProductvendorRowUnsaved {
  implicit lazy val jsonDecoder: JsonDecoder[ProductvendorRowUnsaved] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val productid = jsonObj.get("productid").toRight("Missing field 'productid'").flatMap(_.as(ProductId.jsonDecoder))
    val businessentityid = jsonObj.get("businessentityid").toRight("Missing field 'businessentityid'").flatMap(_.as(BusinessentityId.jsonDecoder))
    val averageleadtime = jsonObj.get("averageleadtime").toRight("Missing field 'averageleadtime'").flatMap(_.as(JsonDecoder.int))
    val standardprice = jsonObj.get("standardprice").toRight("Missing field 'standardprice'").flatMap(_.as(JsonDecoder.scalaBigDecimal))
    val lastreceiptcost = jsonObj.get("lastreceiptcost").fold[Either[String, Option[BigDecimal]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.scalaBigDecimal)))
    val lastreceiptdate = jsonObj.get("lastreceiptdate").fold[Either[String, Option[TypoLocalDateTime]]](Right(None))(_.as(JsonDecoder.option(using TypoLocalDateTime.jsonDecoder)))
    val minorderqty = jsonObj.get("minorderqty").toRight("Missing field 'minorderqty'").flatMap(_.as(JsonDecoder.int))
    val maxorderqty = jsonObj.get("maxorderqty").toRight("Missing field 'maxorderqty'").flatMap(_.as(JsonDecoder.int))
    val onorderqty = jsonObj.get("onorderqty").fold[Either[String, Option[Int]]](Right(None))(_.as(JsonDecoder.option(using JsonDecoder.int)))
    val unitmeasurecode = jsonObj.get("unitmeasurecode").toRight("Missing field 'unitmeasurecode'").flatMap(_.as(UnitmeasureId.jsonDecoder))
    val modifieddate = jsonObj.get("modifieddate").toRight("Missing field 'modifieddate'").flatMap(_.as(Defaulted.jsonDecoder(TypoLocalDateTime.jsonDecoder)))
    if (productid.isRight && businessentityid.isRight && averageleadtime.isRight && standardprice.isRight && lastreceiptcost.isRight && lastreceiptdate.isRight && minorderqty.isRight && maxorderqty.isRight && onorderqty.isRight && unitmeasurecode.isRight && modifieddate.isRight)
      Right(ProductvendorRowUnsaved(productid = productid.toOption.get, businessentityid = businessentityid.toOption.get, averageleadtime = averageleadtime.toOption.get, standardprice = standardprice.toOption.get, lastreceiptcost = lastreceiptcost.toOption.get, lastreceiptdate = lastreceiptdate.toOption.get, minorderqty = minorderqty.toOption.get, maxorderqty = maxorderqty.toOption.get, onorderqty = onorderqty.toOption.get, unitmeasurecode = unitmeasurecode.toOption.get, modifieddate = modifieddate.toOption.get))
    else Left(List[Either[String, Any]](productid, businessentityid, averageleadtime, standardprice, lastreceiptcost, lastreceiptdate, minorderqty, maxorderqty, onorderqty, unitmeasurecode, modifieddate).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[ProductvendorRowUnsaved] = new JsonEncoder[ProductvendorRowUnsaved] {
    override def unsafeEncode(a: ProductvendorRowUnsaved, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""productid":""")
      ProductId.jsonEncoder.unsafeEncode(a.productid, indent, out)
      out.write(",")
      out.write(""""businessentityid":""")
      BusinessentityId.jsonEncoder.unsafeEncode(a.businessentityid, indent, out)
      out.write(",")
      out.write(""""averageleadtime":""")
      JsonEncoder.int.unsafeEncode(a.averageleadtime, indent, out)
      out.write(",")
      out.write(""""standardprice":""")
      JsonEncoder.scalaBigDecimal.unsafeEncode(a.standardprice, indent, out)
      out.write(",")
      out.write(""""lastreceiptcost":""")
      JsonEncoder.option(using JsonEncoder.scalaBigDecimal).unsafeEncode(a.lastreceiptcost, indent, out)
      out.write(",")
      out.write(""""lastreceiptdate":""")
      JsonEncoder.option(using TypoLocalDateTime.jsonEncoder).unsafeEncode(a.lastreceiptdate, indent, out)
      out.write(",")
      out.write(""""minorderqty":""")
      JsonEncoder.int.unsafeEncode(a.minorderqty, indent, out)
      out.write(",")
      out.write(""""maxorderqty":""")
      JsonEncoder.int.unsafeEncode(a.maxorderqty, indent, out)
      out.write(",")
      out.write(""""onorderqty":""")
      JsonEncoder.option(using JsonEncoder.int).unsafeEncode(a.onorderqty, indent, out)
      out.write(",")
      out.write(""""unitmeasurecode":""")
      UnitmeasureId.jsonEncoder.unsafeEncode(a.unitmeasurecode, indent, out)
      out.write(",")
      out.write(""""modifieddate":""")
      Defaulted.jsonEncoder(TypoLocalDateTime.jsonEncoder).unsafeEncode(a.modifieddate, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[ProductvendorRowUnsaved] = Text.instance[ProductvendorRowUnsaved]{ (row, sb) =>
    ProductId.text.unsafeEncode(row.productid, sb)
    sb.append(Text.DELIMETER)
    BusinessentityId.text.unsafeEncode(row.businessentityid, sb)
    sb.append(Text.DELIMETER)
    Text.intInstance.unsafeEncode(row.averageleadtime, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.standardprice, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.bigDecimalInstance).unsafeEncode(row.lastreceiptcost, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.lastreceiptdate, sb)
    sb.append(Text.DELIMETER)
    Text.intInstance.unsafeEncode(row.minorderqty, sb)
    sb.append(Text.DELIMETER)
    Text.intInstance.unsafeEncode(row.maxorderqty, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.intInstance).unsafeEncode(row.onorderqty, sb)
    sb.append(Text.DELIMETER)
    UnitmeasureId.text.unsafeEncode(row.unitmeasurecode, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(TypoLocalDateTime.text).unsafeEncode(row.modifieddate, sb)
  }
}
