/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package pg_catalog
package pg_index

import adventureworks.customtypes.TypoInt2Vector
import adventureworks.customtypes.TypoOidVector
import adventureworks.customtypes.TypoPgNodeTree
import adventureworks.customtypes.TypoShort
import java.sql.ResultSet
import zio.jdbc.JdbcDecoder
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

case class PgIndexRow(
  indexrelid: PgIndexId,
  indrelid: /* oid */ Long,
  indnatts: TypoShort,
  indnkeyatts: TypoShort,
  indisunique: Boolean,
  indisprimary: Boolean,
  indisexclusion: Boolean,
  indimmediate: Boolean,
  indisclustered: Boolean,
  indisvalid: Boolean,
  indcheckxmin: Boolean,
  indisready: Boolean,
  indislive: Boolean,
  indisreplident: Boolean,
  indkey: TypoInt2Vector,
  indcollation: TypoOidVector,
  indclass: TypoOidVector,
  indoption: TypoInt2Vector,
  indexprs: Option[TypoPgNodeTree],
  indpred: Option[TypoPgNodeTree]
)

object PgIndexRow {
  implicit lazy val jdbcDecoder: JdbcDecoder[PgIndexRow] = new JdbcDecoder[PgIndexRow] {
    override def unsafeDecode(columIndex: Int, rs: ResultSet): (Int, PgIndexRow) =
      columIndex + 19 ->
        PgIndexRow(
          indexrelid = PgIndexId.jdbcDecoder.unsafeDecode(columIndex + 0, rs)._2,
          indrelid = JdbcDecoder.longDecoder.unsafeDecode(columIndex + 1, rs)._2,
          indnatts = TypoShort.jdbcDecoder.unsafeDecode(columIndex + 2, rs)._2,
          indnkeyatts = TypoShort.jdbcDecoder.unsafeDecode(columIndex + 3, rs)._2,
          indisunique = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 4, rs)._2,
          indisprimary = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 5, rs)._2,
          indisexclusion = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 6, rs)._2,
          indimmediate = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 7, rs)._2,
          indisclustered = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 8, rs)._2,
          indisvalid = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 9, rs)._2,
          indcheckxmin = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 10, rs)._2,
          indisready = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 11, rs)._2,
          indislive = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 12, rs)._2,
          indisreplident = JdbcDecoder.booleanDecoder.unsafeDecode(columIndex + 13, rs)._2,
          indkey = TypoInt2Vector.jdbcDecoder.unsafeDecode(columIndex + 14, rs)._2,
          indcollation = TypoOidVector.jdbcDecoder.unsafeDecode(columIndex + 15, rs)._2,
          indclass = TypoOidVector.jdbcDecoder.unsafeDecode(columIndex + 16, rs)._2,
          indoption = TypoInt2Vector.jdbcDecoder.unsafeDecode(columIndex + 17, rs)._2,
          indexprs = JdbcDecoder.optionDecoder(TypoPgNodeTree.jdbcDecoder).unsafeDecode(columIndex + 18, rs)._2,
          indpred = JdbcDecoder.optionDecoder(TypoPgNodeTree.jdbcDecoder).unsafeDecode(columIndex + 19, rs)._2
        )
  }
  implicit lazy val jsonDecoder: JsonDecoder[PgIndexRow] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val indexrelid = jsonObj.get("indexrelid").toRight("Missing field 'indexrelid'").flatMap(_.as(PgIndexId.jsonDecoder))
    val indrelid = jsonObj.get("indrelid").toRight("Missing field 'indrelid'").flatMap(_.as(JsonDecoder.long))
    val indnatts = jsonObj.get("indnatts").toRight("Missing field 'indnatts'").flatMap(_.as(TypoShort.jsonDecoder))
    val indnkeyatts = jsonObj.get("indnkeyatts").toRight("Missing field 'indnkeyatts'").flatMap(_.as(TypoShort.jsonDecoder))
    val indisunique = jsonObj.get("indisunique").toRight("Missing field 'indisunique'").flatMap(_.as(JsonDecoder.boolean))
    val indisprimary = jsonObj.get("indisprimary").toRight("Missing field 'indisprimary'").flatMap(_.as(JsonDecoder.boolean))
    val indisexclusion = jsonObj.get("indisexclusion").toRight("Missing field 'indisexclusion'").flatMap(_.as(JsonDecoder.boolean))
    val indimmediate = jsonObj.get("indimmediate").toRight("Missing field 'indimmediate'").flatMap(_.as(JsonDecoder.boolean))
    val indisclustered = jsonObj.get("indisclustered").toRight("Missing field 'indisclustered'").flatMap(_.as(JsonDecoder.boolean))
    val indisvalid = jsonObj.get("indisvalid").toRight("Missing field 'indisvalid'").flatMap(_.as(JsonDecoder.boolean))
    val indcheckxmin = jsonObj.get("indcheckxmin").toRight("Missing field 'indcheckxmin'").flatMap(_.as(JsonDecoder.boolean))
    val indisready = jsonObj.get("indisready").toRight("Missing field 'indisready'").flatMap(_.as(JsonDecoder.boolean))
    val indislive = jsonObj.get("indislive").toRight("Missing field 'indislive'").flatMap(_.as(JsonDecoder.boolean))
    val indisreplident = jsonObj.get("indisreplident").toRight("Missing field 'indisreplident'").flatMap(_.as(JsonDecoder.boolean))
    val indkey = jsonObj.get("indkey").toRight("Missing field 'indkey'").flatMap(_.as(TypoInt2Vector.jsonDecoder))
    val indcollation = jsonObj.get("indcollation").toRight("Missing field 'indcollation'").flatMap(_.as(TypoOidVector.jsonDecoder))
    val indclass = jsonObj.get("indclass").toRight("Missing field 'indclass'").flatMap(_.as(TypoOidVector.jsonDecoder))
    val indoption = jsonObj.get("indoption").toRight("Missing field 'indoption'").flatMap(_.as(TypoInt2Vector.jsonDecoder))
    val indexprs = jsonObj.get("indexprs").fold[Either[String, Option[TypoPgNodeTree]]](Right(None))(_.as(JsonDecoder.option(TypoPgNodeTree.jsonDecoder)))
    val indpred = jsonObj.get("indpred").fold[Either[String, Option[TypoPgNodeTree]]](Right(None))(_.as(JsonDecoder.option(TypoPgNodeTree.jsonDecoder)))
    if (indexrelid.isRight && indrelid.isRight && indnatts.isRight && indnkeyatts.isRight && indisunique.isRight && indisprimary.isRight && indisexclusion.isRight && indimmediate.isRight && indisclustered.isRight && indisvalid.isRight && indcheckxmin.isRight && indisready.isRight && indislive.isRight && indisreplident.isRight && indkey.isRight && indcollation.isRight && indclass.isRight && indoption.isRight && indexprs.isRight && indpred.isRight)
      Right(PgIndexRow(indexrelid = indexrelid.toOption.get, indrelid = indrelid.toOption.get, indnatts = indnatts.toOption.get, indnkeyatts = indnkeyatts.toOption.get, indisunique = indisunique.toOption.get, indisprimary = indisprimary.toOption.get, indisexclusion = indisexclusion.toOption.get, indimmediate = indimmediate.toOption.get, indisclustered = indisclustered.toOption.get, indisvalid = indisvalid.toOption.get, indcheckxmin = indcheckxmin.toOption.get, indisready = indisready.toOption.get, indislive = indislive.toOption.get, indisreplident = indisreplident.toOption.get, indkey = indkey.toOption.get, indcollation = indcollation.toOption.get, indclass = indclass.toOption.get, indoption = indoption.toOption.get, indexprs = indexprs.toOption.get, indpred = indpred.toOption.get))
    else Left(List[Either[String, Any]](indexrelid, indrelid, indnatts, indnkeyatts, indisunique, indisprimary, indisexclusion, indimmediate, indisclustered, indisvalid, indcheckxmin, indisready, indislive, indisreplident, indkey, indcollation, indclass, indoption, indexprs, indpred).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[PgIndexRow] = new JsonEncoder[PgIndexRow] {
    override def unsafeEncode(a: PgIndexRow, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""indexrelid":""")
      PgIndexId.jsonEncoder.unsafeEncode(a.indexrelid, indent, out)
      out.write(",")
      out.write(""""indrelid":""")
      JsonEncoder.long.unsafeEncode(a.indrelid, indent, out)
      out.write(",")
      out.write(""""indnatts":""")
      TypoShort.jsonEncoder.unsafeEncode(a.indnatts, indent, out)
      out.write(",")
      out.write(""""indnkeyatts":""")
      TypoShort.jsonEncoder.unsafeEncode(a.indnkeyatts, indent, out)
      out.write(",")
      out.write(""""indisunique":""")
      JsonEncoder.boolean.unsafeEncode(a.indisunique, indent, out)
      out.write(",")
      out.write(""""indisprimary":""")
      JsonEncoder.boolean.unsafeEncode(a.indisprimary, indent, out)
      out.write(",")
      out.write(""""indisexclusion":""")
      JsonEncoder.boolean.unsafeEncode(a.indisexclusion, indent, out)
      out.write(",")
      out.write(""""indimmediate":""")
      JsonEncoder.boolean.unsafeEncode(a.indimmediate, indent, out)
      out.write(",")
      out.write(""""indisclustered":""")
      JsonEncoder.boolean.unsafeEncode(a.indisclustered, indent, out)
      out.write(",")
      out.write(""""indisvalid":""")
      JsonEncoder.boolean.unsafeEncode(a.indisvalid, indent, out)
      out.write(",")
      out.write(""""indcheckxmin":""")
      JsonEncoder.boolean.unsafeEncode(a.indcheckxmin, indent, out)
      out.write(",")
      out.write(""""indisready":""")
      JsonEncoder.boolean.unsafeEncode(a.indisready, indent, out)
      out.write(",")
      out.write(""""indislive":""")
      JsonEncoder.boolean.unsafeEncode(a.indislive, indent, out)
      out.write(",")
      out.write(""""indisreplident":""")
      JsonEncoder.boolean.unsafeEncode(a.indisreplident, indent, out)
      out.write(",")
      out.write(""""indkey":""")
      TypoInt2Vector.jsonEncoder.unsafeEncode(a.indkey, indent, out)
      out.write(",")
      out.write(""""indcollation":""")
      TypoOidVector.jsonEncoder.unsafeEncode(a.indcollation, indent, out)
      out.write(",")
      out.write(""""indclass":""")
      TypoOidVector.jsonEncoder.unsafeEncode(a.indclass, indent, out)
      out.write(",")
      out.write(""""indoption":""")
      TypoInt2Vector.jsonEncoder.unsafeEncode(a.indoption, indent, out)
      out.write(",")
      out.write(""""indexprs":""")
      JsonEncoder.option(TypoPgNodeTree.jsonEncoder).unsafeEncode(a.indexprs, indent, out)
      out.write(",")
      out.write(""""indpred":""")
      JsonEncoder.option(TypoPgNodeTree.jsonEncoder).unsafeEncode(a.indpred, indent, out)
      out.write("}")
    }
  }
}
