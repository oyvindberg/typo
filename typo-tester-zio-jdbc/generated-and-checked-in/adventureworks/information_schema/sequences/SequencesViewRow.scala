/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package information_schema
package sequences

import java.sql.ResultSet
import zio.jdbc.JdbcDecoder
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

case class SequencesViewRow(
  sequenceCatalog: /* nullability unknown */ Option[String],
  sequenceSchema: /* nullability unknown */ Option[String],
  sequenceName: /* nullability unknown */ Option[String],
  dataType: /* nullability unknown */ Option[String],
  numericPrecision: /* nullability unknown */ Option[Int],
  numericPrecisionRadix: /* nullability unknown */ Option[Int],
  numericScale: /* nullability unknown */ Option[Int],
  startValue: /* nullability unknown */ Option[String],
  minimumValue: /* nullability unknown */ Option[String],
  maximumValue: /* nullability unknown */ Option[String],
  increment: /* nullability unknown */ Option[String],
  cycleOption: /* nullability unknown */ Option[/* max 3 chars */ String]
)

object SequencesViewRow {
  implicit lazy val jdbcDecoder: JdbcDecoder[SequencesViewRow] = new JdbcDecoder[SequencesViewRow] {
    override def unsafeDecode(columIndex: Int, rs: ResultSet): (Int, SequencesViewRow) =
      columIndex + 11 ->
        SequencesViewRow(
          sequenceCatalog = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 0, rs)._2,
          sequenceSchema = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 1, rs)._2,
          sequenceName = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 2, rs)._2,
          dataType = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 3, rs)._2,
          numericPrecision = JdbcDecoder.optionDecoder(JdbcDecoder.intDecoder).unsafeDecode(columIndex + 4, rs)._2,
          numericPrecisionRadix = JdbcDecoder.optionDecoder(JdbcDecoder.intDecoder).unsafeDecode(columIndex + 5, rs)._2,
          numericScale = JdbcDecoder.optionDecoder(JdbcDecoder.intDecoder).unsafeDecode(columIndex + 6, rs)._2,
          startValue = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 7, rs)._2,
          minimumValue = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 8, rs)._2,
          maximumValue = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 9, rs)._2,
          increment = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 10, rs)._2,
          cycleOption = JdbcDecoder.optionDecoder(JdbcDecoder.stringDecoder).unsafeDecode(columIndex + 11, rs)._2
        )
  }
  implicit lazy val jsonDecoder: JsonDecoder[SequencesViewRow] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val sequenceCatalog = jsonObj.get("sequence_catalog").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    val sequenceSchema = jsonObj.get("sequence_schema").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    val sequenceName = jsonObj.get("sequence_name").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    val dataType = jsonObj.get("data_type").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    val numericPrecision = jsonObj.get("numeric_precision").fold[Either[String, Option[Int]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.int)))
    val numericPrecisionRadix = jsonObj.get("numeric_precision_radix").fold[Either[String, Option[Int]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.int)))
    val numericScale = jsonObj.get("numeric_scale").fold[Either[String, Option[Int]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.int)))
    val startValue = jsonObj.get("start_value").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    val minimumValue = jsonObj.get("minimum_value").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    val maximumValue = jsonObj.get("maximum_value").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    val increment = jsonObj.get("increment").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    val cycleOption = jsonObj.get("cycle_option").fold[Either[String, Option[String]]](Right(None))(_.as(JsonDecoder.option(JsonDecoder.string)))
    if (sequenceCatalog.isRight && sequenceSchema.isRight && sequenceName.isRight && dataType.isRight && numericPrecision.isRight && numericPrecisionRadix.isRight && numericScale.isRight && startValue.isRight && minimumValue.isRight && maximumValue.isRight && increment.isRight && cycleOption.isRight)
      Right(SequencesViewRow(sequenceCatalog = sequenceCatalog.toOption.get, sequenceSchema = sequenceSchema.toOption.get, sequenceName = sequenceName.toOption.get, dataType = dataType.toOption.get, numericPrecision = numericPrecision.toOption.get, numericPrecisionRadix = numericPrecisionRadix.toOption.get, numericScale = numericScale.toOption.get, startValue = startValue.toOption.get, minimumValue = minimumValue.toOption.get, maximumValue = maximumValue.toOption.get, increment = increment.toOption.get, cycleOption = cycleOption.toOption.get))
    else Left(List[Either[String, Any]](sequenceCatalog, sequenceSchema, sequenceName, dataType, numericPrecision, numericPrecisionRadix, numericScale, startValue, minimumValue, maximumValue, increment, cycleOption).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[SequencesViewRow] = new JsonEncoder[SequencesViewRow] {
    override def unsafeEncode(a: SequencesViewRow, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""sequence_catalog":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.sequenceCatalog, indent, out)
      out.write(",")
      out.write(""""sequence_schema":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.sequenceSchema, indent, out)
      out.write(",")
      out.write(""""sequence_name":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.sequenceName, indent, out)
      out.write(",")
      out.write(""""data_type":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.dataType, indent, out)
      out.write(",")
      out.write(""""numeric_precision":""")
      JsonEncoder.option(JsonEncoder.int).unsafeEncode(a.numericPrecision, indent, out)
      out.write(",")
      out.write(""""numeric_precision_radix":""")
      JsonEncoder.option(JsonEncoder.int).unsafeEncode(a.numericPrecisionRadix, indent, out)
      out.write(",")
      out.write(""""numeric_scale":""")
      JsonEncoder.option(JsonEncoder.int).unsafeEncode(a.numericScale, indent, out)
      out.write(",")
      out.write(""""start_value":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.startValue, indent, out)
      out.write(",")
      out.write(""""minimum_value":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.minimumValue, indent, out)
      out.write(",")
      out.write(""""maximum_value":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.maximumValue, indent, out)
      out.write(",")
      out.write(""""increment":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.increment, indent, out)
      out.write(",")
      out.write(""""cycle_option":""")
      JsonEncoder.option(JsonEncoder.string).unsafeEncode(a.cycleOption, indent, out)
      out.write("}")
    }
  }
}
