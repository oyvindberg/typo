/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package public
package titledperson

import adventureworks.public.title.TitleId
import adventureworks.public.title_domain.TitleDomainId
import java.sql.ResultSet
import zio.jdbc.JdbcDecoder
import zio.json.JsonDecoder
import zio.json.JsonEncoder
import zio.json.ast.Json
import zio.json.internal.Write

/** Table: public.titledperson */
case class TitledpersonRow(
  /** Points to [[title_domain.TitleDomainRow.code]] */
  titleShort: TitleDomainId,
  /** Points to [[title.TitleRow.code]] */
  title: TitleId,
  name: String
)

object TitledpersonRow {
  implicit lazy val jdbcDecoder: JdbcDecoder[TitledpersonRow] = new JdbcDecoder[TitledpersonRow] {
    override def unsafeDecode(columIndex: Int, rs: ResultSet): (Int, TitledpersonRow) =
      columIndex + 2 ->
        TitledpersonRow(
          titleShort = TitleDomainId.jdbcDecoder.unsafeDecode(columIndex + 0, rs)._2,
          title = TitleId.jdbcDecoder.unsafeDecode(columIndex + 1, rs)._2,
          name = JdbcDecoder.stringDecoder.unsafeDecode(columIndex + 2, rs)._2
        )
  }
  implicit lazy val jsonDecoder: JsonDecoder[TitledpersonRow] = JsonDecoder[Json.Obj].mapOrFail { jsonObj =>
    val titleShort = jsonObj.get("title_short").toRight("Missing field 'title_short'").flatMap(_.as(TitleDomainId.jsonDecoder))
    val title = jsonObj.get("title").toRight("Missing field 'title'").flatMap(_.as(TitleId.jsonDecoder))
    val name = jsonObj.get("name").toRight("Missing field 'name'").flatMap(_.as(JsonDecoder.string))
    if (titleShort.isRight && title.isRight && name.isRight)
      Right(TitledpersonRow(titleShort = titleShort.toOption.get, title = title.toOption.get, name = name.toOption.get))
    else Left(List[Either[String, Any]](titleShort, title, name).flatMap(_.left.toOption).mkString(", "))
  }
  implicit lazy val jsonEncoder: JsonEncoder[TitledpersonRow] = new JsonEncoder[TitledpersonRow] {
    override def unsafeEncode(a: TitledpersonRow, indent: Option[Int], out: Write): Unit = {
      out.write("{")
      out.write(""""title_short":""")
      TitleDomainId.jsonEncoder.unsafeEncode(a.titleShort, indent, out)
      out.write(",")
      out.write(""""title":""")
      TitleId.jsonEncoder.unsafeEncode(a.title, indent, out)
      out.write(",")
      out.write(""""name":""")
      JsonEncoder.string.unsafeEncode(a.name, indent, out)
      out.write("}")
    }
  }
  implicit lazy val text: Text[TitledpersonRow] = Text.instance[TitledpersonRow]{ (row, sb) =>
    TitleDomainId.text.unsafeEncode(row.titleShort, sb)
    sb.append(Text.DELIMETER)
    TitleId.text.unsafeEncode(row.title, sb)
    sb.append(Text.DELIMETER)
    Text.stringInstance.unsafeEncode(row.name, sb)
  }
}
