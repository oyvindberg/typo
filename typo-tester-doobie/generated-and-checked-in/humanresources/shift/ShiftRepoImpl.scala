/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package humanresources
package shift

import adventureworks.Defaulted
import adventureworks.public.Name
import doobie.Get
import doobie.Read
import doobie.enumerated.Nullability
import doobie.free.connection.ConnectionIO
import doobie.free.connection.pure
import doobie.syntax.string.toSqlInterpolator
import doobie.util.fragment.Fragment
import doobie.util.fragments
import fs2.Stream
import java.sql.ResultSet
import java.time.LocalDateTime
import java.time.LocalTime

object ShiftRepoImpl extends ShiftRepo {
  override def delete(shiftid: ShiftId): ConnectionIO[Boolean] = {
    sql"delete from humanresources.shift where shiftid = $shiftid".update.run.map(_ > 0)
  }
  override def insert(unsaved: ShiftRow): ConnectionIO[ShiftRow] = {
    sql"""insert into humanresources.shift(shiftid, "name", starttime, endtime, modifieddate)
          values (${unsaved.shiftid}::int4, ${unsaved.name}::public.Name, ${unsaved.starttime}::time, ${unsaved.endtime}::time, ${unsaved.modifieddate}::timestamp)
          returning shiftid, "name", starttime, endtime, modifieddate
       """.query.unique
  }
  override def insert(unsaved: ShiftRowUnsaved): ConnectionIO[ShiftRow] = {
    val fs = List(
      Some((Fragment.const(s""""name""""), fr""""name" = ${unsaved.name}::public.Name""")),
      Some((Fragment.const(s"starttime"), fr"starttime = ${unsaved.starttime}::time")),
      Some((Fragment.const(s"endtime"), fr"endtime = ${unsaved.endtime}::time")),
      unsaved.shiftid match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"shiftid"), fr"shiftid = ${value: ShiftId}::int4"))
      },
      unsaved.modifieddate match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"modifieddate"), fr"modifieddate = ${value: LocalDateTime}::timestamp"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into humanresources.shift default values
            returning shiftid, "name", starttime, endtime, modifieddate
         """
    } else {
      import cats.syntax.foldable.toFoldableOps
      sql"""insert into humanresources.shift(${fs.map { case (n, _) => n }.intercalate(fr", ")})
            set ${fs.map { case (_, f) => f }.intercalate(fr", ")}
            returning shiftid, "name", starttime, endtime, modifieddate
         """
    }
    q.query.unique
  
  }
  override def selectAll: Stream[ConnectionIO, ShiftRow] = {
    sql"""select shiftid, "name", starttime, endtime, modifieddate from humanresources.shift""".query[ShiftRow].stream
  }
  override def selectByFieldValues(fieldValues: List[ShiftFieldOrIdValue[_]]): Stream[ConnectionIO, ShiftRow] = {
    val where = fragments.whereAnd(
      fieldValues.map {
        case ShiftFieldValue.shiftid(value) => fr"shiftid = $value"
        case ShiftFieldValue.name(value) => fr""""name" = $value"""
        case ShiftFieldValue.starttime(value) => fr"starttime = $value"
        case ShiftFieldValue.endtime(value) => fr"endtime = $value"
        case ShiftFieldValue.modifieddate(value) => fr"modifieddate = $value"
      } :_*
    )
    sql"select * from humanresources.shift $where".query[ShiftRow].stream
  
  }
  override def selectById(shiftid: ShiftId): ConnectionIO[Option[ShiftRow]] = {
    sql"""select shiftid, "name", starttime, endtime, modifieddate from humanresources.shift where shiftid = $shiftid""".query[ShiftRow].option
  }
  override def selectByIds(shiftids: Array[ShiftId]): Stream[ConnectionIO, ShiftRow] = {
    sql"""select shiftid, "name", starttime, endtime, modifieddate from humanresources.shift where shiftid in $shiftids""".query[ShiftRow].stream
  }
  override def update(row: ShiftRow): ConnectionIO[Boolean] = {
    val shiftid = row.shiftid
    sql"""update humanresources.shift
          set "name" = ${row.name}::public.Name,
              starttime = ${row.starttime}::time,
              endtime = ${row.endtime}::time,
              modifieddate = ${row.modifieddate}::timestamp
          where shiftid = $shiftid
       """
      .update
      .run
      .map(_ > 0)
  }
  override def updateFieldValues(shiftid: ShiftId, fieldValues: List[ShiftFieldValue[_]]): ConnectionIO[Boolean] = {
    fieldValues match {
      case Nil => pure(false)
      case nonEmpty =>
        val updates = fragments.set(
          nonEmpty.map {
            case ShiftFieldValue.name(value) => fr"name = $value"
            case ShiftFieldValue.starttime(value) => fr"starttime = $value"
            case ShiftFieldValue.endtime(value) => fr"endtime = $value"
            case ShiftFieldValue.modifieddate(value) => fr"modifieddate = $value"
          } :_*
        )
        sql"""update humanresources.shift
              set $updates
              where shiftid = $shiftid
           """.update.run.map(_ > 0)
    }
  }
  override def upsert(unsaved: ShiftRow): ConnectionIO[ShiftRow] = {
    sql"""insert into humanresources.shift(shiftid, "name", starttime, endtime, modifieddate)
          values (
            ${unsaved.shiftid}::int4,
            ${unsaved.name}::public.Name,
            ${unsaved.starttime}::time,
            ${unsaved.endtime}::time,
            ${unsaved.modifieddate}::timestamp
          )
          on conflict (shiftid)
          do update set
            "name" = EXCLUDED."name",
            starttime = EXCLUDED.starttime,
            endtime = EXCLUDED.endtime,
            modifieddate = EXCLUDED.modifieddate
          returning shiftid, "name", starttime, endtime, modifieddate
       """.query.unique
  }
  implicit val read: Read[ShiftRow] =
    new Read[ShiftRow](
      gets = List(
        (Get[ShiftId], Nullability.NoNulls),
        (Get[Name], Nullability.NoNulls),
        (Get[LocalTime], Nullability.NoNulls),
        (Get[LocalTime], Nullability.NoNulls),
        (Get[LocalDateTime], Nullability.NoNulls)
      ),
      unsafeGet = (rs: ResultSet, i: Int) => ShiftRow(
        shiftid = Get[ShiftId].unsafeGetNonNullable(rs, i + 0),
        name = Get[Name].unsafeGetNonNullable(rs, i + 1),
        starttime = Get[LocalTime].unsafeGetNonNullable(rs, i + 2),
        endtime = Get[LocalTime].unsafeGetNonNullable(rs, i + 3),
        modifieddate = Get[LocalDateTime].unsafeGetNonNullable(rs, i + 4)
      )
    )
  

}
