/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package user

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.frontpage.department.DepartmentId
import doobie.postgres.Text
import doobie.util.Read
import doobie.util.Write
import doobie.util.meta.Meta
import io.circe.Decoder
import io.circe.Encoder

/** Table: frontpage.user
    Primary key: id */
case class UserRow(
  /** Default: gen_random_uuid() */
  id: UserId,
  email: Email,
  name: String,
  /** Default: now() */
  createdAt: Option[TypoLocalDateTime],
  /** Points to [[department.DepartmentRow.id]] */
  departmentId: Option[DepartmentId],
  /** Default: 'active'::frontpage.user_status */
  status: Option[UserStatus],
  /** Default: false */
  verified: Option[Boolean],
  /** Points to [[UserRow.id]] */
  managerId: Option[UserId],
  /** Default: 'employee'::frontpage.user_role */
  role: Option[UserRole]
){
   def toUnsavedRow(id: Defaulted[UserId], createdAt: Defaulted[Option[TypoLocalDateTime]] = Defaulted.Provided(this.createdAt), status: Defaulted[Option[UserStatus]] = Defaulted.Provided(this.status), verified: Defaulted[Option[Boolean]] = Defaulted.Provided(this.verified), role: Defaulted[Option[UserRole]] = Defaulted.Provided(this.role)): UserRowUnsaved =
     UserRowUnsaved(email, name, departmentId, managerId, id, createdAt, status, verified, role)
 }

object UserRow {
  implicit lazy val decoder: Decoder[UserRow] = Decoder.forProduct9[UserRow, UserId, Email, String, Option[TypoLocalDateTime], Option[DepartmentId], Option[UserStatus], Option[Boolean], Option[UserId], Option[UserRole]]("id", "email", "name", "created_at", "department_id", "status", "verified", "manager_id", "role")(UserRow.apply)(UserId.decoder, Email.decoder, Decoder.decodeString, Decoder.decodeOption(TypoLocalDateTime.decoder), Decoder.decodeOption(DepartmentId.decoder), Decoder.decodeOption(UserStatus.decoder), Decoder.decodeOption(Decoder.decodeBoolean), Decoder.decodeOption(UserId.decoder), Decoder.decodeOption(UserRole.decoder))
  implicit lazy val encoder: Encoder[UserRow] = Encoder.forProduct9[UserRow, UserId, Email, String, Option[TypoLocalDateTime], Option[DepartmentId], Option[UserStatus], Option[Boolean], Option[UserId], Option[UserRole]]("id", "email", "name", "created_at", "department_id", "status", "verified", "manager_id", "role")(x => (x.id, x.email, x.name, x.createdAt, x.departmentId, x.status, x.verified, x.managerId, x.role))(UserId.encoder, Email.encoder, Encoder.encodeString, Encoder.encodeOption(TypoLocalDateTime.encoder), Encoder.encodeOption(DepartmentId.encoder), Encoder.encodeOption(UserStatus.encoder), Encoder.encodeOption(Encoder.encodeBoolean), Encoder.encodeOption(UserId.encoder), Encoder.encodeOption(UserRole.encoder))
  implicit lazy val read: Read[UserRow] = new Read.CompositeOfInstances(Array(
    new Read.Single(UserId.get).asInstanceOf[Read[Any]],
      new Read.Single(Email.get).asInstanceOf[Read[Any]],
      new Read.Single(Meta.StringMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(TypoLocalDateTime.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(DepartmentId.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(UserStatus.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(Meta.BooleanMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(UserId.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(UserRole.get).asInstanceOf[Read[Any]]
  ))(using scala.reflect.ClassTag.Any).map { arr =>
    UserRow(
      id = arr(0).asInstanceOf[UserId],
          email = arr(1).asInstanceOf[Email],
          name = arr(2).asInstanceOf[String],
          createdAt = arr(3).asInstanceOf[Option[TypoLocalDateTime]],
          departmentId = arr(4).asInstanceOf[Option[DepartmentId]],
          status = arr(5).asInstanceOf[Option[UserStatus]],
          verified = arr(6).asInstanceOf[Option[Boolean]],
          managerId = arr(7).asInstanceOf[Option[UserId]],
          role = arr(8).asInstanceOf[Option[UserRole]]
    )
  }
  implicit lazy val text: Text[UserRow] = Text.instance[UserRow]{ (row, sb) =>
    UserId.text.unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Email.text.unsafeEncode(row.email, sb)
    sb.append(Text.DELIMETER)
    Text.stringInstance.unsafeEncode(row.name, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.createdAt, sb)
    sb.append(Text.DELIMETER)
    Text.option(DepartmentId.text).unsafeEncode(row.departmentId, sb)
    sb.append(Text.DELIMETER)
    Text.option(UserStatus.text).unsafeEncode(row.status, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.booleanInstance).unsafeEncode(row.verified, sb)
    sb.append(Text.DELIMETER)
    Text.option(UserId.text).unsafeEncode(row.managerId, sb)
    sb.append(Text.DELIMETER)
    Text.option(UserRole.text).unsafeEncode(row.role, sb)
  }
  implicit lazy val write: Write[UserRow] = new Write.Composite[UserRow](
    List(new Write.Single(UserId.put),
         new Write.Single(Email.put),
         new Write.Single(Meta.StringMeta.put),
         new Write.Single(TypoLocalDateTime.put).toOpt,
         new Write.Single(DepartmentId.put).toOpt,
         new Write.Single(UserStatus.put).toOpt,
         new Write.Single(Meta.BooleanMeta.put).toOpt,
         new Write.Single(UserId.put).toOpt,
         new Write.Single(UserRole.put).toOpt),
    a => List(a.id, a.email, a.name, a.createdAt, a.departmentId, a.status, a.verified, a.managerId, a.role)
  )
}
