/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package user

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.frontpage.department.DepartmentId
import doobie.postgres.Text
import io.circe.Decoder
import io.circe.Encoder

/** This class corresponds to a row in table `frontpage.user` which has not been persisted yet */
case class UserRowUnsaved(
  email: Email,
  name: String,
  /** Points to [[department.DepartmentRow.id]] */
  departmentId: Option[DepartmentId],
  /** Points to [[UserRow.id]] */
  managerId: Option[UserId],
  /** Default: gen_random_uuid() */
  id: Defaulted[UserId] = Defaulted.UseDefault,
  /** Default: now() */
  createdAt: Defaulted[Option[TypoLocalDateTime]] = Defaulted.UseDefault,
  /** Default: 'active'::frontpage.user_status */
  status: Defaulted[Option[UserStatus]] = Defaulted.UseDefault,
  /** Default: false */
  verified: Defaulted[Option[Boolean]] = Defaulted.UseDefault,
  /** Default: 'employee'::frontpage.user_role */
  role: Defaulted[Option[UserRole]] = Defaulted.UseDefault
) {
  def toRow(idDefault: => UserId, createdAtDefault: => Option[TypoLocalDateTime], statusDefault: => Option[UserStatus], verifiedDefault: => Option[Boolean], roleDefault: => Option[UserRole]): UserRow =
    UserRow(
      email = email,
      name = name,
      departmentId = departmentId,
      managerId = managerId,
      id = id match {
             case Defaulted.UseDefault => idDefault
             case Defaulted.Provided(value) => value
           },
      createdAt = createdAt match {
                    case Defaulted.UseDefault => createdAtDefault
                    case Defaulted.Provided(value) => value
                  },
      status = status match {
                 case Defaulted.UseDefault => statusDefault
                 case Defaulted.Provided(value) => value
               },
      verified = verified match {
                   case Defaulted.UseDefault => verifiedDefault
                   case Defaulted.Provided(value) => value
                 },
      role = role match {
               case Defaulted.UseDefault => roleDefault
               case Defaulted.Provided(value) => value
             }
    )
}
object UserRowUnsaved {
  implicit lazy val decoder: Decoder[UserRowUnsaved] = Decoder.forProduct9[UserRowUnsaved, Email, String, Option[DepartmentId], Option[UserId], Defaulted[UserId], Defaulted[Option[TypoLocalDateTime]], Defaulted[Option[UserStatus]], Defaulted[Option[Boolean]], Defaulted[Option[UserRole]]]("email", "name", "department_id", "manager_id", "id", "created_at", "status", "verified", "role")(UserRowUnsaved.apply)(Email.decoder, Decoder.decodeString, Decoder.decodeOption(DepartmentId.decoder), Decoder.decodeOption(UserId.decoder), Defaulted.decoder(UserId.decoder), Defaulted.decoder(Decoder.decodeOption(TypoLocalDateTime.decoder)), Defaulted.decoder(Decoder.decodeOption(UserStatus.decoder)), Defaulted.decoder(Decoder.decodeOption(Decoder.decodeBoolean)), Defaulted.decoder(Decoder.decodeOption(UserRole.decoder)))
  implicit lazy val encoder: Encoder[UserRowUnsaved] = Encoder.forProduct9[UserRowUnsaved, Email, String, Option[DepartmentId], Option[UserId], Defaulted[UserId], Defaulted[Option[TypoLocalDateTime]], Defaulted[Option[UserStatus]], Defaulted[Option[Boolean]], Defaulted[Option[UserRole]]]("email", "name", "department_id", "manager_id", "id", "created_at", "status", "verified", "role")(x => (x.email, x.name, x.departmentId, x.managerId, x.id, x.createdAt, x.status, x.verified, x.role))(Email.encoder, Encoder.encodeString, Encoder.encodeOption(DepartmentId.encoder), Encoder.encodeOption(UserId.encoder), Defaulted.encoder(UserId.encoder), Defaulted.encoder(Encoder.encodeOption(TypoLocalDateTime.encoder)), Defaulted.encoder(Encoder.encodeOption(UserStatus.encoder)), Defaulted.encoder(Encoder.encodeOption(Encoder.encodeBoolean)), Defaulted.encoder(Encoder.encodeOption(UserRole.encoder)))
  implicit lazy val text: Text[UserRowUnsaved] = Text.instance[UserRowUnsaved]{ (row, sb) =>
    Email.text.unsafeEncode(row.email, sb)
    sb.append(Text.DELIMETER)
    Text.stringInstance.unsafeEncode(row.name, sb)
    sb.append(Text.DELIMETER)
    Text.option(DepartmentId.text).unsafeEncode(row.departmentId, sb)
    sb.append(Text.DELIMETER)
    Text.option(UserId.text).unsafeEncode(row.managerId, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(UserId.text).unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(TypoLocalDateTime.text)).unsafeEncode(row.createdAt, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(UserStatus.text)).unsafeEncode(row.status, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text.booleanInstance)).unsafeEncode(row.verified, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(UserRole.text)).unsafeEncode(row.role, sb)
  }
}
