/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package customer

import adventureworks.customtypes.Defaulted
import adventureworks.frontpage.user.UserId
import doobie.postgres.Text
import doobie.util.Read
import doobie.util.Write
import doobie.util.meta.Meta
import io.circe.Decoder
import io.circe.Encoder

/** Table: frontpage.customer
    Primary key: id */
case class CustomerRow(
  /** Default: gen_random_uuid() */
  id: CustomerId,
  /** Points to [[user.UserRow.id]] */
  userId: Option[UserId],
  companyName: Option[String],
  creditLimit: Option[BigDecimal],
  /** Default: false */
  verified: Option[Boolean]
){
   def toUnsavedRow(id: Defaulted[CustomerId], verified: Defaulted[Option[Boolean]] = Defaulted.Provided(this.verified)): CustomerRowUnsaved =
     CustomerRowUnsaved(userId, companyName, creditLimit, id, verified)
 }

object CustomerRow {
  implicit lazy val decoder: Decoder[CustomerRow] = Decoder.forProduct5[CustomerRow, CustomerId, Option[UserId], Option[String], Option[BigDecimal], Option[Boolean]]("id", "user_id", "company_name", "credit_limit", "verified")(CustomerRow.apply)(CustomerId.decoder, Decoder.decodeOption(UserId.decoder), Decoder.decodeOption(Decoder.decodeString), Decoder.decodeOption(Decoder.decodeBigDecimal), Decoder.decodeOption(Decoder.decodeBoolean))
  implicit lazy val encoder: Encoder[CustomerRow] = Encoder.forProduct5[CustomerRow, CustomerId, Option[UserId], Option[String], Option[BigDecimal], Option[Boolean]]("id", "user_id", "company_name", "credit_limit", "verified")(x => (x.id, x.userId, x.companyName, x.creditLimit, x.verified))(CustomerId.encoder, Encoder.encodeOption(UserId.encoder), Encoder.encodeOption(Encoder.encodeString), Encoder.encodeOption(Encoder.encodeBigDecimal), Encoder.encodeOption(Encoder.encodeBoolean))
  implicit lazy val read: Read[CustomerRow] = new Read.CompositeOfInstances(Array(
    new Read.Single(CustomerId.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(UserId.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(Meta.StringMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(Meta.ScalaBigDecimalMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(Meta.BooleanMeta.get).asInstanceOf[Read[Any]]
  ))(using scala.reflect.ClassTag.Any).map { arr =>
    CustomerRow(
      id = arr(0).asInstanceOf[CustomerId],
          userId = arr(1).asInstanceOf[Option[UserId]],
          companyName = arr(2).asInstanceOf[Option[String]],
          creditLimit = arr(3).asInstanceOf[Option[BigDecimal]],
          verified = arr(4).asInstanceOf[Option[Boolean]]
    )
  }
  implicit lazy val text: Text[CustomerRow] = Text.instance[CustomerRow]{ (row, sb) =>
    CustomerId.text.unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Text.option(UserId.text).unsafeEncode(row.userId, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.stringInstance).unsafeEncode(row.companyName, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.bigDecimalInstance).unsafeEncode(row.creditLimit, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.booleanInstance).unsafeEncode(row.verified, sb)
  }
  implicit lazy val write: Write[CustomerRow] = new Write.Composite[CustomerRow](
    List(new Write.Single(CustomerId.put),
         new Write.Single(UserId.put).toOpt,
         new Write.Single(Meta.StringMeta.put).toOpt,
         new Write.Single(Meta.ScalaBigDecimalMeta.put).toOpt,
         new Write.Single(Meta.BooleanMeta.put).toOpt),
    a => List(a.id, a.userId, a.companyName, a.creditLimit, a.verified)
  )
}
