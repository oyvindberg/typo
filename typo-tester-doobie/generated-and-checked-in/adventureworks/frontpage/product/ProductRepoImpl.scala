/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package product

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoJsonb
import adventureworks.customtypes.TypoLocalDateTime
import cats.instances.list.catsStdInstancesForList
import doobie.free.connection.ConnectionIO
import doobie.postgres.syntax.FragmentOps
import doobie.syntax.SqlInterpolator.SingleFragment.fromWrite
import doobie.syntax.string.toSqlInterpolator
import doobie.util.Write
import doobie.util.fragment.Fragment
import doobie.util.meta.Meta
import doobie.util.update.Update
import fs2.Stream
import typo.dsl.DeleteBuilder
import typo.dsl.SelectBuilder
import typo.dsl.SelectBuilderSql
import typo.dsl.UpdateBuilder

class ProductRepoImpl extends ProductRepo {
  override def delete: DeleteBuilder[ProductFields, ProductRow] = {
    DeleteBuilder(""""frontpage"."product"""", ProductFields.structure)
  }
  override def deleteById(id: ProductId): ConnectionIO[Boolean] = {
    sql"""delete from "frontpage"."product" where "id" = ${fromWrite(id)(new Write.Single(ProductId.put))}""".update.run.map(_ > 0)
  }
  override def deleteByIds(ids: Array[ProductId]): ConnectionIO[Int] = {
    sql"""delete from "frontpage"."product" where "id" = ANY(${ids})""".update.run
  }
  override def insert(unsaved: ProductRow): ConnectionIO[ProductRow] = {
    sql"""insert into "frontpage"."product"("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes")
          values (${fromWrite(unsaved.id)(new Write.Single(ProductId.put))}::uuid, ${fromWrite(unsaved.name)(new Write.Single(Meta.StringMeta.put))}, ${fromWrite(unsaved.price)(new Write.Single(Meta.ScalaBigDecimalMeta.put))}::numeric, ${fromWrite(unsaved.inStock)(new Write.SingleOpt(Meta.BooleanMeta.put))}, ${fromWrite(unsaved.quantity)(new Write.SingleOpt(Meta.IntMeta.put))}::int4, ${fromWrite(unsaved.lastRestocked)(new Write.SingleOpt(TypoLocalDateTime.put))}::timestamp, ${fromWrite(unsaved.lastModified)(new Write.SingleOpt(TypoLocalDateTime.put))}::timestamp, ${fromWrite(unsaved.tags)(new Write.SingleOpt(adventureworks.StringArrayMeta.put))}::text[], ${fromWrite(unsaved.categories)(new Write.SingleOpt(adventureworks.IntegerArrayMeta.put))}::int4[], ${fromWrite(unsaved.prices)(new Write.SingleOpt(adventureworks.BigDecimalMeta.put))}::numeric[], ${fromWrite(unsaved.attributes)(new Write.SingleOpt(TypoJsonb.arrayPut))}::jsonb[])
          returning "id", "name", "price", "in_stock", "quantity", "last_restocked"::text, "last_modified"::text, "tags", "categories", "prices", "attributes"
       """.query(using ProductRow.read).unique
  }
  override def insert(unsaved: ProductRowUnsaved): ConnectionIO[ProductRow] = {
    val fs = List(
      Some((Fragment.const0(s""""name""""), fr"${fromWrite(unsaved.name)(new Write.Single(Meta.StringMeta.put))}")),
      Some((Fragment.const0(s""""price""""), fr"${fromWrite(unsaved.price)(new Write.Single(Meta.ScalaBigDecimalMeta.put))}::numeric")),
      Some((Fragment.const0(s""""last_restocked""""), fr"${fromWrite(unsaved.lastRestocked)(new Write.SingleOpt(TypoLocalDateTime.put))}::timestamp")),
      unsaved.id match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const0(s""""id""""), fr"${fromWrite(value: ProductId)(new Write.Single(ProductId.put))}::uuid"))
      },
      unsaved.inStock match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const0(s""""in_stock""""), fr"${fromWrite(value: Option[Boolean])(new Write.SingleOpt(Meta.BooleanMeta.put))}"))
      },
      unsaved.quantity match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const0(s""""quantity""""), fr"${fromWrite(value: Option[Int])(new Write.SingleOpt(Meta.IntMeta.put))}::int4"))
      },
      unsaved.lastModified match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const0(s""""last_modified""""), fr"${fromWrite(value: Option[TypoLocalDateTime])(new Write.SingleOpt(TypoLocalDateTime.put))}::timestamp"))
      },
      unsaved.tags match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const0(s""""tags""""), fr"${fromWrite(value: Option[Array[String]])(new Write.SingleOpt(adventureworks.StringArrayMeta.put))}::text[]"))
      },
      unsaved.categories match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const0(s""""categories""""), fr"${fromWrite(value: Option[Array[Int]])(new Write.SingleOpt(adventureworks.IntegerArrayMeta.put))}::int4[]"))
      },
      unsaved.prices match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const0(s""""prices""""), fr"${fromWrite(value: Option[Array[BigDecimal]])(new Write.SingleOpt(adventureworks.BigDecimalMeta.put))}::numeric[]"))
      },
      unsaved.attributes match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const0(s""""attributes""""), fr"${fromWrite(value: Option[Array[TypoJsonb]])(new Write.SingleOpt(TypoJsonb.arrayPut))}::jsonb[]"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into "frontpage"."product" default values
            returning "id", "name", "price", "in_stock", "quantity", "last_restocked"::text, "last_modified"::text, "tags", "categories", "prices", "attributes"
         """
    } else {
      val CommaSeparate = Fragment.FragmentMonoid.intercalate(fr", ")
      sql"""insert into "frontpage"."product"(${CommaSeparate.combineAllOption(fs.map { case (n, _) => n }).get})
            values (${CommaSeparate.combineAllOption(fs.map { case (_, f) => f }).get})
            returning "id", "name", "price", "in_stock", "quantity", "last_restocked"::text, "last_modified"::text, "tags", "categories", "prices", "attributes"
         """
    }
    q.query(using ProductRow.read).unique
    
  }
  override def insertStreaming(unsaved: Stream[ConnectionIO, ProductRow], batchSize: Int = 10000): ConnectionIO[Long] = {
    new FragmentOps(sql"""COPY "frontpage"."product"("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes") FROM STDIN""").copyIn(unsaved, batchSize)(using ProductRow.text)
  }
  /* NOTE: this functionality requires PostgreSQL 16 or later! */
  override def insertUnsavedStreaming(unsaved: Stream[ConnectionIO, ProductRowUnsaved], batchSize: Int = 10000): ConnectionIO[Long] = {
    new FragmentOps(sql"""COPY "frontpage"."product"("name", "price", "last_restocked", "id", "in_stock", "quantity", "last_modified", "tags", "categories", "prices", "attributes") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')""").copyIn(unsaved, batchSize)(using ProductRowUnsaved.text)
  }
  override def select: SelectBuilder[ProductFields, ProductRow] = {
    SelectBuilderSql(""""frontpage"."product"""", ProductFields.structure, ProductRow.read)
  }
  override def selectAll: Stream[ConnectionIO, ProductRow] = {
    sql"""select "id", "name", "price", "in_stock", "quantity", "last_restocked"::text, "last_modified"::text, "tags", "categories", "prices", "attributes" from "frontpage"."product"""".query(using ProductRow.read).stream
  }
  override def selectById(id: ProductId): ConnectionIO[Option[ProductRow]] = {
    sql"""select "id", "name", "price", "in_stock", "quantity", "last_restocked"::text, "last_modified"::text, "tags", "categories", "prices", "attributes" from "frontpage"."product" where "id" = ${fromWrite(id)(new Write.Single(ProductId.put))}""".query(using ProductRow.read).option
  }
  override def selectByIds(ids: Array[ProductId]): Stream[ConnectionIO, ProductRow] = {
    sql"""select "id", "name", "price", "in_stock", "quantity", "last_restocked"::text, "last_modified"::text, "tags", "categories", "prices", "attributes" from "frontpage"."product" where "id" = ANY(${ids})""".query(using ProductRow.read).stream
  }
  override def selectByIdsTracked(ids: Array[ProductId]): ConnectionIO[Map[ProductId, ProductRow]] = {
    selectByIds(ids).compile.toList.map { rows =>
      val byId = rows.view.map(x => (x.id, x)).toMap
      ids.view.flatMap(id => byId.get(id).map(x => (id, x))).toMap
    }
  }
  override def update: UpdateBuilder[ProductFields, ProductRow] = {
    UpdateBuilder(""""frontpage"."product"""", ProductFields.structure, ProductRow.read)
  }
  override def update(row: ProductRow): ConnectionIO[Boolean] = {
    val id = row.id
    sql"""update "frontpage"."product"
          set "name" = ${fromWrite(row.name)(new Write.Single(Meta.StringMeta.put))},
              "price" = ${fromWrite(row.price)(new Write.Single(Meta.ScalaBigDecimalMeta.put))}::numeric,
              "in_stock" = ${fromWrite(row.inStock)(new Write.SingleOpt(Meta.BooleanMeta.put))},
              "quantity" = ${fromWrite(row.quantity)(new Write.SingleOpt(Meta.IntMeta.put))}::int4,
              "last_restocked" = ${fromWrite(row.lastRestocked)(new Write.SingleOpt(TypoLocalDateTime.put))}::timestamp,
              "last_modified" = ${fromWrite(row.lastModified)(new Write.SingleOpt(TypoLocalDateTime.put))}::timestamp,
              "tags" = ${fromWrite(row.tags)(new Write.SingleOpt(adventureworks.StringArrayMeta.put))}::text[],
              "categories" = ${fromWrite(row.categories)(new Write.SingleOpt(adventureworks.IntegerArrayMeta.put))}::int4[],
              "prices" = ${fromWrite(row.prices)(new Write.SingleOpt(adventureworks.BigDecimalMeta.put))}::numeric[],
              "attributes" = ${fromWrite(row.attributes)(new Write.SingleOpt(TypoJsonb.arrayPut))}::jsonb[]
          where "id" = ${fromWrite(id)(new Write.Single(ProductId.put))}"""
      .update
      .run
      .map(_ > 0)
  }
  override def upsert(unsaved: ProductRow): ConnectionIO[ProductRow] = {
    sql"""insert into "frontpage"."product"("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes")
          values (
            ${fromWrite(unsaved.id)(new Write.Single(ProductId.put))}::uuid,
            ${fromWrite(unsaved.name)(new Write.Single(Meta.StringMeta.put))},
            ${fromWrite(unsaved.price)(new Write.Single(Meta.ScalaBigDecimalMeta.put))}::numeric,
            ${fromWrite(unsaved.inStock)(new Write.SingleOpt(Meta.BooleanMeta.put))},
            ${fromWrite(unsaved.quantity)(new Write.SingleOpt(Meta.IntMeta.put))}::int4,
            ${fromWrite(unsaved.lastRestocked)(new Write.SingleOpt(TypoLocalDateTime.put))}::timestamp,
            ${fromWrite(unsaved.lastModified)(new Write.SingleOpt(TypoLocalDateTime.put))}::timestamp,
            ${fromWrite(unsaved.tags)(new Write.SingleOpt(adventureworks.StringArrayMeta.put))}::text[],
            ${fromWrite(unsaved.categories)(new Write.SingleOpt(adventureworks.IntegerArrayMeta.put))}::int4[],
            ${fromWrite(unsaved.prices)(new Write.SingleOpt(adventureworks.BigDecimalMeta.put))}::numeric[],
            ${fromWrite(unsaved.attributes)(new Write.SingleOpt(TypoJsonb.arrayPut))}::jsonb[]
          )
          on conflict ("id")
          do update set
            "name" = EXCLUDED."name",
            "price" = EXCLUDED."price",
            "in_stock" = EXCLUDED."in_stock",
            "quantity" = EXCLUDED."quantity",
            "last_restocked" = EXCLUDED."last_restocked",
            "last_modified" = EXCLUDED."last_modified",
            "tags" = EXCLUDED."tags",
            "categories" = EXCLUDED."categories",
            "prices" = EXCLUDED."prices",
            "attributes" = EXCLUDED."attributes"
          returning "id", "name", "price", "in_stock", "quantity", "last_restocked"::text, "last_modified"::text, "tags", "categories", "prices", "attributes"
       """.query(using ProductRow.read).unique
  }
  override def upsertBatch(unsaved: List[ProductRow]): Stream[ConnectionIO, ProductRow] = {
    Update[ProductRow](
      s"""insert into "frontpage"."product"("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes")
          values (?::uuid,?,?::numeric,?,?::int4,?::timestamp,?::timestamp,?::text[],?::int4[],?::numeric[],?::jsonb[])
          on conflict ("id")
          do update set
            "name" = EXCLUDED."name",
            "price" = EXCLUDED."price",
            "in_stock" = EXCLUDED."in_stock",
            "quantity" = EXCLUDED."quantity",
            "last_restocked" = EXCLUDED."last_restocked",
            "last_modified" = EXCLUDED."last_modified",
            "tags" = EXCLUDED."tags",
            "categories" = EXCLUDED."categories",
            "prices" = EXCLUDED."prices",
            "attributes" = EXCLUDED."attributes"
          returning "id", "name", "price", "in_stock", "quantity", "last_restocked"::text, "last_modified"::text, "tags", "categories", "prices", "attributes""""
    )(using ProductRow.write)
    .updateManyWithGeneratedKeys[ProductRow]("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes")(unsaved)(using catsStdInstancesForList, ProductRow.read)
  }
  /* NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override def upsertStreaming(unsaved: Stream[ConnectionIO, ProductRow], batchSize: Int = 10000): ConnectionIO[Int] = {
    for {
      _ <- sql"""create temporary table product_TEMP (like "frontpage"."product") on commit drop""".update.run
      _ <- new FragmentOps(sql"""copy product_TEMP("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes") from stdin""").copyIn(unsaved, batchSize)(using ProductRow.text)
      res <- sql"""insert into "frontpage"."product"("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes")
                   select * from product_TEMP
                   on conflict ("id")
                   do update set
                     "name" = EXCLUDED."name",
                     "price" = EXCLUDED."price",
                     "in_stock" = EXCLUDED."in_stock",
                     "quantity" = EXCLUDED."quantity",
                     "last_restocked" = EXCLUDED."last_restocked",
                     "last_modified" = EXCLUDED."last_modified",
                     "tags" = EXCLUDED."tags",
                     "categories" = EXCLUDED."categories",
                     "prices" = EXCLUDED."prices",
                     "attributes" = EXCLUDED."attributes"
                   ;
                   drop table product_TEMP;""".update.run
    } yield res
  }
}
