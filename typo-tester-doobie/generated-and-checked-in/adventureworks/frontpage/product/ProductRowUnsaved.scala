/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package product

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoJsonb
import adventureworks.customtypes.TypoLocalDateTime
import doobie.postgres.Text
import io.circe.Decoder
import io.circe.Encoder

/** This class corresponds to a row in table `frontpage.product` which has not been persisted yet */
case class ProductRowUnsaved(
  name: String,
  price: BigDecimal,
  lastRestocked: Option[TypoLocalDateTime],
  /** Default: gen_random_uuid() */
  id: Defaulted[ProductId] = Defaulted.UseDefault,
  /** Default: true */
  inStock: Defaulted[Option[Boolean]] = Defaulted.UseDefault,
  /** Default: 0 */
  quantity: Defaulted[Option[Int]] = Defaulted.UseDefault,
  /** Default: now() */
  lastModified: Defaulted[Option[TypoLocalDateTime]] = Defaulted.UseDefault,
  /** Default: '{}'::text[] */
  tags: Defaulted[Option[Array[String]]] = Defaulted.UseDefault,
  /** Default: '{}'::integer[] */
  categories: Defaulted[Option[Array[Int]]] = Defaulted.UseDefault,
  /** Default: '{}'::numeric[] */
  prices: Defaulted[Option[Array[BigDecimal]]] = Defaulted.UseDefault,
  /** Default: '{}'::jsonb[] */
  attributes: Defaulted[Option[Array[TypoJsonb]]] = Defaulted.UseDefault
) {
  def toRow(idDefault: => ProductId, inStockDefault: => Option[Boolean], quantityDefault: => Option[Int], lastModifiedDefault: => Option[TypoLocalDateTime], tagsDefault: => Option[Array[String]], categoriesDefault: => Option[Array[Int]], pricesDefault: => Option[Array[BigDecimal]], attributesDefault: => Option[Array[TypoJsonb]]): ProductRow =
    ProductRow(
      name = name,
      price = price,
      lastRestocked = lastRestocked,
      id = id match {
             case Defaulted.UseDefault => idDefault
             case Defaulted.Provided(value) => value
           },
      inStock = inStock match {
                  case Defaulted.UseDefault => inStockDefault
                  case Defaulted.Provided(value) => value
                },
      quantity = quantity match {
                   case Defaulted.UseDefault => quantityDefault
                   case Defaulted.Provided(value) => value
                 },
      lastModified = lastModified match {
                       case Defaulted.UseDefault => lastModifiedDefault
                       case Defaulted.Provided(value) => value
                     },
      tags = tags match {
               case Defaulted.UseDefault => tagsDefault
               case Defaulted.Provided(value) => value
             },
      categories = categories match {
                     case Defaulted.UseDefault => categoriesDefault
                     case Defaulted.Provided(value) => value
                   },
      prices = prices match {
                 case Defaulted.UseDefault => pricesDefault
                 case Defaulted.Provided(value) => value
               },
      attributes = attributes match {
                     case Defaulted.UseDefault => attributesDefault
                     case Defaulted.Provided(value) => value
                   }
    )
}
object ProductRowUnsaved {
  implicit lazy val decoder: Decoder[ProductRowUnsaved] = Decoder.forProduct11[ProductRowUnsaved, String, BigDecimal, Option[TypoLocalDateTime], Defaulted[ProductId], Defaulted[Option[Boolean]], Defaulted[Option[Int]], Defaulted[Option[TypoLocalDateTime]], Defaulted[Option[Array[String]]], Defaulted[Option[Array[Int]]], Defaulted[Option[Array[BigDecimal]]], Defaulted[Option[Array[TypoJsonb]]]]("name", "price", "last_restocked", "id", "in_stock", "quantity", "last_modified", "tags", "categories", "prices", "attributes")(ProductRowUnsaved.apply)(Decoder.decodeString, Decoder.decodeBigDecimal, Decoder.decodeOption(TypoLocalDateTime.decoder), Defaulted.decoder(ProductId.decoder), Defaulted.decoder(Decoder.decodeOption(Decoder.decodeBoolean)), Defaulted.decoder(Decoder.decodeOption(Decoder.decodeInt)), Defaulted.decoder(Decoder.decodeOption(TypoLocalDateTime.decoder)), Defaulted.decoder(Decoder.decodeOption(Decoder.decodeArray[String](Decoder.decodeString, implicitly))), Defaulted.decoder(Decoder.decodeOption(Decoder.decodeArray[Int](Decoder.decodeInt, implicitly))), Defaulted.decoder(Decoder.decodeOption(Decoder.decodeArray[BigDecimal](Decoder.decodeBigDecimal, implicitly))), Defaulted.decoder(Decoder.decodeOption(Decoder.decodeArray[TypoJsonb](TypoJsonb.decoder, implicitly))))
  implicit lazy val encoder: Encoder[ProductRowUnsaved] = Encoder.forProduct11[ProductRowUnsaved, String, BigDecimal, Option[TypoLocalDateTime], Defaulted[ProductId], Defaulted[Option[Boolean]], Defaulted[Option[Int]], Defaulted[Option[TypoLocalDateTime]], Defaulted[Option[Array[String]]], Defaulted[Option[Array[Int]]], Defaulted[Option[Array[BigDecimal]]], Defaulted[Option[Array[TypoJsonb]]]]("name", "price", "last_restocked", "id", "in_stock", "quantity", "last_modified", "tags", "categories", "prices", "attributes")(x => (x.name, x.price, x.lastRestocked, x.id, x.inStock, x.quantity, x.lastModified, x.tags, x.categories, x.prices, x.attributes))(Encoder.encodeString, Encoder.encodeBigDecimal, Encoder.encodeOption(TypoLocalDateTime.encoder), Defaulted.encoder(ProductId.encoder), Defaulted.encoder(Encoder.encodeOption(Encoder.encodeBoolean)), Defaulted.encoder(Encoder.encodeOption(Encoder.encodeInt)), Defaulted.encoder(Encoder.encodeOption(TypoLocalDateTime.encoder)), Defaulted.encoder(Encoder.encodeOption(Encoder.encodeIterable[String, Array](Encoder.encodeString, implicitly))), Defaulted.encoder(Encoder.encodeOption(Encoder.encodeIterable[Int, Array](Encoder.encodeInt, implicitly))), Defaulted.encoder(Encoder.encodeOption(Encoder.encodeIterable[BigDecimal, Array](Encoder.encodeBigDecimal, implicitly))), Defaulted.encoder(Encoder.encodeOption(Encoder.encodeIterable[TypoJsonb, Array](TypoJsonb.encoder, implicitly))))
  implicit lazy val text: Text[ProductRowUnsaved] = Text.instance[ProductRowUnsaved]{ (row, sb) =>
    Text.stringInstance.unsafeEncode(row.name, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.price, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.lastRestocked, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(ProductId.text).unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text.booleanInstance)).unsafeEncode(row.inStock, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text.intInstance)).unsafeEncode(row.quantity, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(TypoLocalDateTime.text)).unsafeEncode(row.lastModified, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text[Array[String]])).unsafeEncode(row.tags, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text[Array[Int]])).unsafeEncode(row.categories, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text[Array[BigDecimal]])).unsafeEncode(row.prices, sb)
    sb.append(Text.DELIMETER)
    Defaulted.text(Text.option(Text.iterableInstance[Array, TypoJsonb](TypoJsonb.text, implicitly))).unsafeEncode(row.attributes, sb)
  }
}
