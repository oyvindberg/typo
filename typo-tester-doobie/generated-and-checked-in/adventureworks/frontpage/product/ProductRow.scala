/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package product

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoJsonb
import adventureworks.customtypes.TypoLocalDateTime
import doobie.postgres.Text
import doobie.util.Read
import doobie.util.Write
import doobie.util.meta.Meta
import io.circe.Decoder
import io.circe.Encoder

/** Table: frontpage.product
    Primary key: id */
case class ProductRow(
  /** Default: gen_random_uuid() */
  id: ProductId,
  name: String,
  price: BigDecimal,
  /** Default: true */
  inStock: Option[Boolean],
  /** Default: 0 */
  quantity: Option[Int],
  lastRestocked: Option[TypoLocalDateTime],
  /** Default: now() */
  lastModified: Option[TypoLocalDateTime],
  /** Default: '{}'::text[] */
  tags: Option[Array[String]],
  /** Default: '{}'::integer[] */
  categories: Option[Array[Int]],
  /** Default: '{}'::numeric[] */
  prices: Option[Array[BigDecimal]],
  /** Default: '{}'::jsonb[] */
  attributes: Option[Array[TypoJsonb]]
){
   def toUnsavedRow(id: Defaulted[ProductId], inStock: Defaulted[Option[Boolean]] = Defaulted.Provided(this.inStock), quantity: Defaulted[Option[Int]] = Defaulted.Provided(this.quantity), lastModified: Defaulted[Option[TypoLocalDateTime]] = Defaulted.Provided(this.lastModified), tags: Defaulted[Option[Array[String]]] = Defaulted.Provided(this.tags), categories: Defaulted[Option[Array[Int]]] = Defaulted.Provided(this.categories), prices: Defaulted[Option[Array[BigDecimal]]] = Defaulted.Provided(this.prices), attributes: Defaulted[Option[Array[TypoJsonb]]] = Defaulted.Provided(this.attributes)): ProductRowUnsaved =
     ProductRowUnsaved(name, price, lastRestocked, id, inStock, quantity, lastModified, tags, categories, prices, attributes)
 }

object ProductRow {
  implicit lazy val decoder: Decoder[ProductRow] = Decoder.forProduct11[ProductRow, ProductId, String, BigDecimal, Option[Boolean], Option[Int], Option[TypoLocalDateTime], Option[TypoLocalDateTime], Option[Array[String]], Option[Array[Int]], Option[Array[BigDecimal]], Option[Array[TypoJsonb]]]("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes")(ProductRow.apply)(ProductId.decoder, Decoder.decodeString, Decoder.decodeBigDecimal, Decoder.decodeOption(Decoder.decodeBoolean), Decoder.decodeOption(Decoder.decodeInt), Decoder.decodeOption(TypoLocalDateTime.decoder), Decoder.decodeOption(TypoLocalDateTime.decoder), Decoder.decodeOption(Decoder.decodeArray[String](Decoder.decodeString, implicitly)), Decoder.decodeOption(Decoder.decodeArray[Int](Decoder.decodeInt, implicitly)), Decoder.decodeOption(Decoder.decodeArray[BigDecimal](Decoder.decodeBigDecimal, implicitly)), Decoder.decodeOption(Decoder.decodeArray[TypoJsonb](TypoJsonb.decoder, implicitly)))
  implicit lazy val encoder: Encoder[ProductRow] = Encoder.forProduct11[ProductRow, ProductId, String, BigDecimal, Option[Boolean], Option[Int], Option[TypoLocalDateTime], Option[TypoLocalDateTime], Option[Array[String]], Option[Array[Int]], Option[Array[BigDecimal]], Option[Array[TypoJsonb]]]("id", "name", "price", "in_stock", "quantity", "last_restocked", "last_modified", "tags", "categories", "prices", "attributes")(x => (x.id, x.name, x.price, x.inStock, x.quantity, x.lastRestocked, x.lastModified, x.tags, x.categories, x.prices, x.attributes))(ProductId.encoder, Encoder.encodeString, Encoder.encodeBigDecimal, Encoder.encodeOption(Encoder.encodeBoolean), Encoder.encodeOption(Encoder.encodeInt), Encoder.encodeOption(TypoLocalDateTime.encoder), Encoder.encodeOption(TypoLocalDateTime.encoder), Encoder.encodeOption(Encoder.encodeIterable[String, Array](Encoder.encodeString, implicitly)), Encoder.encodeOption(Encoder.encodeIterable[Int, Array](Encoder.encodeInt, implicitly)), Encoder.encodeOption(Encoder.encodeIterable[BigDecimal, Array](Encoder.encodeBigDecimal, implicitly)), Encoder.encodeOption(Encoder.encodeIterable[TypoJsonb, Array](TypoJsonb.encoder, implicitly)))
  implicit lazy val read: Read[ProductRow] = new Read.CompositeOfInstances(Array(
    new Read.Single(ProductId.get).asInstanceOf[Read[Any]],
      new Read.Single(Meta.StringMeta.get).asInstanceOf[Read[Any]],
      new Read.Single(Meta.ScalaBigDecimalMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(Meta.BooleanMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(Meta.IntMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(TypoLocalDateTime.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(TypoLocalDateTime.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(adventureworks.StringArrayMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(adventureworks.IntegerArrayMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(adventureworks.BigDecimalMeta.get).asInstanceOf[Read[Any]],
      new Read.SingleOpt(TypoJsonb.arrayGet).asInstanceOf[Read[Any]]
  ))(using scala.reflect.ClassTag.Any).map { arr =>
    ProductRow(
      id = arr(0).asInstanceOf[ProductId],
          name = arr(1).asInstanceOf[String],
          price = arr(2).asInstanceOf[BigDecimal],
          inStock = arr(3).asInstanceOf[Option[Boolean]],
          quantity = arr(4).asInstanceOf[Option[Int]],
          lastRestocked = arr(5).asInstanceOf[Option[TypoLocalDateTime]],
          lastModified = arr(6).asInstanceOf[Option[TypoLocalDateTime]],
          tags = arr(7).asInstanceOf[Option[Array[String]]],
          categories = arr(8).asInstanceOf[Option[Array[Int]]],
          prices = arr(9).asInstanceOf[Option[Array[BigDecimal]]],
          attributes = arr(10).asInstanceOf[Option[Array[TypoJsonb]]]
    )
  }
  implicit lazy val text: Text[ProductRow] = Text.instance[ProductRow]{ (row, sb) =>
    ProductId.text.unsafeEncode(row.id, sb)
    sb.append(Text.DELIMETER)
    Text.stringInstance.unsafeEncode(row.name, sb)
    sb.append(Text.DELIMETER)
    Text.bigDecimalInstance.unsafeEncode(row.price, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.booleanInstance).unsafeEncode(row.inStock, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.intInstance).unsafeEncode(row.quantity, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.lastRestocked, sb)
    sb.append(Text.DELIMETER)
    Text.option(TypoLocalDateTime.text).unsafeEncode(row.lastModified, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text[Array[String]]).unsafeEncode(row.tags, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text[Array[Int]]).unsafeEncode(row.categories, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text[Array[BigDecimal]]).unsafeEncode(row.prices, sb)
    sb.append(Text.DELIMETER)
    Text.option(Text.iterableInstance[Array, TypoJsonb](TypoJsonb.text, implicitly)).unsafeEncode(row.attributes, sb)
  }
  implicit lazy val write: Write[ProductRow] = new Write.Composite[ProductRow](
    List(new Write.Single(ProductId.put),
         new Write.Single(Meta.StringMeta.put),
         new Write.Single(Meta.ScalaBigDecimalMeta.put),
         new Write.Single(Meta.BooleanMeta.put).toOpt,
         new Write.Single(Meta.IntMeta.put).toOpt,
         new Write.Single(TypoLocalDateTime.put).toOpt,
         new Write.Single(TypoLocalDateTime.put).toOpt,
         new Write.Single(adventureworks.StringArrayMeta.put).toOpt,
         new Write.Single(adventureworks.IntegerArrayMeta.put).toOpt,
         new Write.Single(adventureworks.BigDecimalMeta.put).toOpt,
         new Write.Single(TypoJsonb.arrayPut).toOpt),
    a => List(a.id, a.name, a.price, a.inStock, a.quantity, a.lastRestocked, a.lastModified, a.tags, a.categories, a.prices, a.attributes)
  )
}
