/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package production
package productphoto

import adventureworks.Defaulted
import doobie.Get
import doobie.Read
import doobie.enumerated.Nullability
import doobie.free.connection.ConnectionIO
import doobie.free.connection.pure
import doobie.syntax.string.toSqlInterpolator
import doobie.util.fragment.Fragment
import doobie.util.fragments
import fs2.Stream
import java.sql.ResultSet
import java.time.LocalDateTime

object ProductphotoRepoImpl extends ProductphotoRepo {
  override def delete(productphotoid: ProductphotoId): ConnectionIO[Boolean] = {
    sql"delete from production.productphoto where productphotoid = $productphotoid".update.run.map(_ > 0)
  }
  override def insert(unsaved: ProductphotoRow): ConnectionIO[ProductphotoRow] = {
    sql"""insert into production.productphoto(productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate)
          values (${unsaved.productphotoid}::int4, ${unsaved.thumbnailphoto}::bytea, ${unsaved.thumbnailphotofilename}, ${unsaved.largephoto}::bytea, ${unsaved.largephotofilename}, ${unsaved.modifieddate}::timestamp)
          returning productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate
       """.query.unique
  }
  override def insert(unsaved: ProductphotoRowUnsaved): ConnectionIO[ProductphotoRow] = {
    val fs = List(
      Some((Fragment.const(s"thumbnailphoto"), fr"${unsaved.thumbnailphoto}::bytea")),
      Some((Fragment.const(s"thumbnailphotofilename"), fr"${unsaved.thumbnailphotofilename}")),
      Some((Fragment.const(s"largephoto"), fr"${unsaved.largephoto}::bytea")),
      Some((Fragment.const(s"largephotofilename"), fr"${unsaved.largephotofilename}")),
      unsaved.productphotoid match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"productphotoid"), fr"${value: ProductphotoId}::int4"))
      },
      unsaved.modifieddate match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"modifieddate"), fr"${value: LocalDateTime}::timestamp"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into production.productphoto default values
            returning productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate
         """
    } else {
      import cats.syntax.foldable.toFoldableOps
      sql"""insert into production.productphoto(${fs.map { case (n, _) => n }.intercalate(fr", ")})
            values (${fs.map { case (_, f) => f }.intercalate(fr", ")})
            returning productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate
         """
    }
    q.query.unique
  
  }
  override def selectAll: Stream[ConnectionIO, ProductphotoRow] = {
    sql"select productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate from production.productphoto".query[ProductphotoRow].stream
  }
  override def selectByFieldValues(fieldValues: List[ProductphotoFieldOrIdValue[_]]): Stream[ConnectionIO, ProductphotoRow] = {
    val where = fragments.whereAnd(
      fieldValues.map {
        case ProductphotoFieldValue.productphotoid(value) => fr"productphotoid = $value"
        case ProductphotoFieldValue.thumbnailphoto(value) => fr"thumbnailphoto = $value"
        case ProductphotoFieldValue.thumbnailphotofilename(value) => fr"thumbnailphotofilename = $value"
        case ProductphotoFieldValue.largephoto(value) => fr"largephoto = $value"
        case ProductphotoFieldValue.largephotofilename(value) => fr"largephotofilename = $value"
        case ProductphotoFieldValue.modifieddate(value) => fr"modifieddate = $value"
      } :_*
    )
    sql"select * from production.productphoto $where".query[ProductphotoRow].stream
  
  }
  override def selectById(productphotoid: ProductphotoId): ConnectionIO[Option[ProductphotoRow]] = {
    sql"select productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate from production.productphoto where productphotoid = $productphotoid".query[ProductphotoRow].option
  }
  override def selectByIds(productphotoids: Array[ProductphotoId]): Stream[ConnectionIO, ProductphotoRow] = {
    sql"select productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate from production.productphoto where productphotoid = ANY($productphotoids)".query[ProductphotoRow].stream
  }
  override def update(row: ProductphotoRow): ConnectionIO[Boolean] = {
    val productphotoid = row.productphotoid
    sql"""update production.productphoto
          set thumbnailphoto = ${row.thumbnailphoto}::bytea,
              thumbnailphotofilename = ${row.thumbnailphotofilename},
              largephoto = ${row.largephoto}::bytea,
              largephotofilename = ${row.largephotofilename},
              modifieddate = ${row.modifieddate}::timestamp
          where productphotoid = $productphotoid
       """
      .update
      .run
      .map(_ > 0)
  }
  override def updateFieldValues(productphotoid: ProductphotoId, fieldValues: List[ProductphotoFieldValue[_]]): ConnectionIO[Boolean] = {
    fieldValues match {
      case Nil => pure(false)
      case nonEmpty =>
        val updates = fragments.set(
          nonEmpty.map {
            case ProductphotoFieldValue.thumbnailphoto(value) => fr"thumbnailphoto = $value"
            case ProductphotoFieldValue.thumbnailphotofilename(value) => fr"thumbnailphotofilename = $value"
            case ProductphotoFieldValue.largephoto(value) => fr"largephoto = $value"
            case ProductphotoFieldValue.largephotofilename(value) => fr"largephotofilename = $value"
            case ProductphotoFieldValue.modifieddate(value) => fr"modifieddate = $value"
          } :_*
        )
        sql"""update production.productphoto
              $updates
              where productphotoid = $productphotoid
           """.update.run.map(_ > 0)
    }
  }
  override def upsert(unsaved: ProductphotoRow): ConnectionIO[ProductphotoRow] = {
    sql"""insert into production.productphoto(productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate)
          values (
            ${unsaved.productphotoid}::int4,
            ${unsaved.thumbnailphoto}::bytea,
            ${unsaved.thumbnailphotofilename},
            ${unsaved.largephoto}::bytea,
            ${unsaved.largephotofilename},
            ${unsaved.modifieddate}::timestamp
          )
          on conflict (productphotoid)
          do update set
            thumbnailphoto = EXCLUDED.thumbnailphoto,
            thumbnailphotofilename = EXCLUDED.thumbnailphotofilename,
            largephoto = EXCLUDED.largephoto,
            largephotofilename = EXCLUDED.largephotofilename,
            modifieddate = EXCLUDED.modifieddate
          returning productphotoid, thumbnailphoto, thumbnailphotofilename, largephoto, largephotofilename, modifieddate
       """.query.unique
  }
  implicit val read: Read[ProductphotoRow] =
    new Read[ProductphotoRow](
      gets = List(
        (Get[ProductphotoId], Nullability.NoNulls),
        (Get[Array[Byte]], Nullability.Nullable),
        (Get[String], Nullability.Nullable),
        (Get[Array[Byte]], Nullability.Nullable),
        (Get[String], Nullability.Nullable),
        (Get[LocalDateTime], Nullability.NoNulls)
      ),
      unsafeGet = (rs: ResultSet, i: Int) => ProductphotoRow(
        productphotoid = Get[ProductphotoId].unsafeGetNonNullable(rs, i + 0),
        thumbnailphoto = Get[Array[Byte]].unsafeGetNullable(rs, i + 1),
        thumbnailphotofilename = Get[String].unsafeGetNullable(rs, i + 2),
        largephoto = Get[Array[Byte]].unsafeGetNullable(rs, i + 3),
        largephotofilename = Get[String].unsafeGetNullable(rs, i + 4),
        modifieddate = Get[LocalDateTime].unsafeGetNonNullable(rs, i + 5)
      )
    )
  

}
