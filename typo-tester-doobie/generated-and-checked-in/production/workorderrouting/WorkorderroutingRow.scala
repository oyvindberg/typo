/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package production
package workorderrouting

import adventureworks.production.location.LocationId
import adventureworks.production.workorder.WorkorderId
import io.circe.Decoder
import io.circe.Encoder
import io.circe.HCursor
import io.circe.Json
import java.time.LocalDateTime

case class WorkorderroutingRow(
  /** Primary key. Foreign key to WorkOrder.WorkOrderID.
      Points to [[workorder.WorkorderRow.workorderid]] */
  workorderid: WorkorderId,
  /** Primary key. Foreign key to Product.ProductID. */
  productid: Int,
  /** Primary key. Indicates the manufacturing process sequence. */
  operationsequence: Int,
  /** Manufacturing location where the part is processed. Foreign key to Location.LocationID.
      Points to [[location.LocationRow.locationid]] */
  locationid: LocationId,
  /** Planned manufacturing start date. */
  scheduledstartdate: LocalDateTime,
  /** Planned manufacturing end date. */
  scheduledenddate: LocalDateTime,
  /** Actual start date. */
  actualstartdate: Option[LocalDateTime],
  /** Actual end date. */
  actualenddate: Option[LocalDateTime],
  /** Number of manufacturing hours used. */
  actualresourcehrs: Option[BigDecimal],
  /** Estimated manufacturing cost. */
  plannedcost: BigDecimal,
  /** Actual manufacturing cost. */
  actualcost: Option[BigDecimal],
  modifieddate: LocalDateTime
){
   val compositeId: WorkorderroutingId = WorkorderroutingId(workorderid, productid, operationsequence)
 }

object WorkorderroutingRow {
  implicit val decoder: Decoder[WorkorderroutingRow] =
    (c: HCursor) =>
      for {
        workorderid <- c.downField("workorderid").as[WorkorderId]
        productid <- c.downField("productid").as[Int]
        operationsequence <- c.downField("operationsequence").as[Int]
        locationid <- c.downField("locationid").as[LocationId]
        scheduledstartdate <- c.downField("scheduledstartdate").as[LocalDateTime]
        scheduledenddate <- c.downField("scheduledenddate").as[LocalDateTime]
        actualstartdate <- c.downField("actualstartdate").as[Option[LocalDateTime]]
        actualenddate <- c.downField("actualenddate").as[Option[LocalDateTime]]
        actualresourcehrs <- c.downField("actualresourcehrs").as[Option[BigDecimal]]
        plannedcost <- c.downField("plannedcost").as[BigDecimal]
        actualcost <- c.downField("actualcost").as[Option[BigDecimal]]
        modifieddate <- c.downField("modifieddate").as[LocalDateTime]
      } yield WorkorderroutingRow(workorderid, productid, operationsequence, locationid, scheduledstartdate, scheduledenddate, actualstartdate, actualenddate, actualresourcehrs, plannedcost, actualcost, modifieddate)
  implicit val encoder: Encoder[WorkorderroutingRow] = {
    import io.circe.syntax._
    row =>
      Json.obj(
        "workorderid" := row.workorderid,
        "productid" := row.productid,
        "operationsequence" := row.operationsequence,
        "locationid" := row.locationid,
        "scheduledstartdate" := row.scheduledstartdate,
        "scheduledenddate" := row.scheduledenddate,
        "actualstartdate" := row.actualstartdate,
        "actualenddate" := row.actualenddate,
        "actualresourcehrs" := row.actualresourcehrs,
        "plannedcost" := row.plannedcost,
        "actualcost" := row.actualcost,
        "modifieddate" := row.modifieddate
      )}
}
