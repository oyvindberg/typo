/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package production
package productreview

import adventureworks.Defaulted
import adventureworks.production.product.ProductId
import adventureworks.public.Name
import doobie.Get
import doobie.Read
import doobie.enumerated.Nullability
import doobie.free.connection.ConnectionIO
import doobie.free.connection.pure
import doobie.syntax.string.toSqlInterpolator
import doobie.util.fragment.Fragment
import doobie.util.fragments
import fs2.Stream
import java.sql.ResultSet
import java.time.LocalDateTime

object ProductreviewRepoImpl extends ProductreviewRepo {
  override def delete(productreviewid: ProductreviewId): ConnectionIO[Boolean] = {
    sql"delete from production.productreview where productreviewid = $productreviewid".update.run.map(_ > 0)
  }
  override def insert(unsaved: ProductreviewRow): ConnectionIO[ProductreviewRow] = {
    sql"""insert into production.productreview(productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate)
          values (${unsaved.productreviewid}::int4, ${unsaved.productid}::int4, ${unsaved.reviewername}::"public"."Name", ${unsaved.reviewdate}::timestamp, ${unsaved.emailaddress}, ${unsaved.rating}::int4, ${unsaved.comments}, ${unsaved.modifieddate}::timestamp)
          returning productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate
       """.query.unique
  }
  override def insert(unsaved: ProductreviewRowUnsaved): ConnectionIO[ProductreviewRow] = {
    val fs = List(
      Some((Fragment.const(s"productid"), fr"${unsaved.productid}::int4")),
      Some((Fragment.const(s"reviewername"), fr"""${unsaved.reviewername}::"public"."Name"""")),
      Some((Fragment.const(s"emailaddress"), fr"${unsaved.emailaddress}")),
      Some((Fragment.const(s"rating"), fr"${unsaved.rating}::int4")),
      Some((Fragment.const(s""""comments""""), fr"${unsaved.comments}")),
      unsaved.productreviewid match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"productreviewid"), fr"${value: ProductreviewId}::int4"))
      },
      unsaved.reviewdate match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"reviewdate"), fr"${value: LocalDateTime}::timestamp"))
      },
      unsaved.modifieddate match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"modifieddate"), fr"${value: LocalDateTime}::timestamp"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into production.productreview default values
            returning productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate
         """
    } else {
      import cats.syntax.foldable.toFoldableOps
      sql"""insert into production.productreview(${fs.map { case (n, _) => n }.intercalate(fr", ")})
            values (${fs.map { case (_, f) => f }.intercalate(fr", ")})
            returning productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate
         """
    }
    q.query.unique
  
  }
  override def selectAll: Stream[ConnectionIO, ProductreviewRow] = {
    sql"""select productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate from production.productreview""".query[ProductreviewRow].stream
  }
  override def selectByFieldValues(fieldValues: List[ProductreviewFieldOrIdValue[_]]): Stream[ConnectionIO, ProductreviewRow] = {
    val where = fragments.whereAnd(
      fieldValues.map {
        case ProductreviewFieldValue.productreviewid(value) => fr"productreviewid = $value"
        case ProductreviewFieldValue.productid(value) => fr"productid = $value"
        case ProductreviewFieldValue.reviewername(value) => fr"reviewername = $value"
        case ProductreviewFieldValue.reviewdate(value) => fr"reviewdate = $value"
        case ProductreviewFieldValue.emailaddress(value) => fr"emailaddress = $value"
        case ProductreviewFieldValue.rating(value) => fr"rating = $value"
        case ProductreviewFieldValue.comments(value) => fr""""comments" = $value"""
        case ProductreviewFieldValue.modifieddate(value) => fr"modifieddate = $value"
      } :_*
    )
    sql"select * from production.productreview $where".query[ProductreviewRow].stream
  
  }
  override def selectById(productreviewid: ProductreviewId): ConnectionIO[Option[ProductreviewRow]] = {
    sql"""select productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate from production.productreview where productreviewid = $productreviewid""".query[ProductreviewRow].option
  }
  override def selectByIds(productreviewids: Array[ProductreviewId]): Stream[ConnectionIO, ProductreviewRow] = {
    sql"""select productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate from production.productreview where productreviewid = ANY($productreviewids)""".query[ProductreviewRow].stream
  }
  override def update(row: ProductreviewRow): ConnectionIO[Boolean] = {
    val productreviewid = row.productreviewid
    sql"""update production.productreview
          set productid = ${row.productid}::int4,
              reviewername = ${row.reviewername}::"public"."Name",
              reviewdate = ${row.reviewdate}::timestamp,
              emailaddress = ${row.emailaddress},
              rating = ${row.rating}::int4,
              "comments" = ${row.comments},
              modifieddate = ${row.modifieddate}::timestamp
          where productreviewid = $productreviewid
       """
      .update
      .run
      .map(_ > 0)
  }
  override def updateFieldValues(productreviewid: ProductreviewId, fieldValues: List[ProductreviewFieldValue[_]]): ConnectionIO[Boolean] = {
    fieldValues match {
      case Nil => pure(false)
      case nonEmpty =>
        val updates = fragments.set(
          nonEmpty.map {
            case ProductreviewFieldValue.productid(value) => fr"productid = $value"
            case ProductreviewFieldValue.reviewername(value) => fr"reviewername = $value"
            case ProductreviewFieldValue.reviewdate(value) => fr"reviewdate = $value"
            case ProductreviewFieldValue.emailaddress(value) => fr"emailaddress = $value"
            case ProductreviewFieldValue.rating(value) => fr"rating = $value"
            case ProductreviewFieldValue.comments(value) => fr""""comments" = $value"""
            case ProductreviewFieldValue.modifieddate(value) => fr"modifieddate = $value"
          } :_*
        )
        sql"""update production.productreview
              $updates
              where productreviewid = $productreviewid
           """.update.run.map(_ > 0)
    }
  }
  override def upsert(unsaved: ProductreviewRow): ConnectionIO[ProductreviewRow] = {
    sql"""insert into production.productreview(productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate)
          values (
            ${unsaved.productreviewid}::int4,
            ${unsaved.productid}::int4,
            ${unsaved.reviewername}::"public"."Name",
            ${unsaved.reviewdate}::timestamp,
            ${unsaved.emailaddress},
            ${unsaved.rating}::int4,
            ${unsaved.comments},
            ${unsaved.modifieddate}::timestamp
          )
          on conflict (productreviewid)
          do update set
            productid = EXCLUDED.productid,
            reviewername = EXCLUDED.reviewername,
            reviewdate = EXCLUDED.reviewdate,
            emailaddress = EXCLUDED.emailaddress,
            rating = EXCLUDED.rating,
            "comments" = EXCLUDED."comments",
            modifieddate = EXCLUDED.modifieddate
          returning productreviewid, productid, reviewername, reviewdate, emailaddress, rating, "comments", modifieddate
       """.query.unique
  }
  implicit val read: Read[ProductreviewRow] =
    new Read[ProductreviewRow](
      gets = List(
        (Get[ProductreviewId], Nullability.NoNulls),
        (Get[ProductId], Nullability.NoNulls),
        (Get[Name], Nullability.NoNulls),
        (Get[LocalDateTime], Nullability.NoNulls),
        (Get[/* max 50 chars */ String], Nullability.NoNulls),
        (Get[Int], Nullability.NoNulls),
        (Get[/* max 3850 chars */ String], Nullability.Nullable),
        (Get[LocalDateTime], Nullability.NoNulls)
      ),
      unsafeGet = (rs: ResultSet, i: Int) => ProductreviewRow(
        productreviewid = Get[ProductreviewId].unsafeGetNonNullable(rs, i + 0),
        productid = Get[ProductId].unsafeGetNonNullable(rs, i + 1),
        reviewername = Get[Name].unsafeGetNonNullable(rs, i + 2),
        reviewdate = Get[LocalDateTime].unsafeGetNonNullable(rs, i + 3),
        emailaddress = Get[/* max 50 chars */ String].unsafeGetNonNullable(rs, i + 4),
        rating = Get[Int].unsafeGetNonNullable(rs, i + 5),
        comments = Get[/* max 3850 chars */ String].unsafeGetNullable(rs, i + 6),
        modifieddate = Get[LocalDateTime].unsafeGetNonNullable(rs, i + 7)
      )
    )
  

}
