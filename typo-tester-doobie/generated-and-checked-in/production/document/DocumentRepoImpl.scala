/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package production
package document

import adventureworks.Defaulted
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.public.Flag
import doobie.Get
import doobie.Read
import doobie.enumerated.Nullability
import doobie.free.connection.ConnectionIO
import doobie.free.connection.pure
import doobie.syntax.string.toSqlInterpolator
import doobie.util.fragment.Fragment
import doobie.util.fragments
import fs2.Stream
import java.sql.ResultSet
import java.time.LocalDateTime
import java.util.UUID

object DocumentRepoImpl extends DocumentRepo {
  override def delete(documentnode: DocumentId): ConnectionIO[Boolean] = {
    sql"""delete from production."document" where documentnode = $documentnode""".update.run.map(_ > 0)
  }
  override def insert(unsaved: DocumentRow): ConnectionIO[DocumentRow] = {
    sql"""insert into production."document"(title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode)
          values (${unsaved.title}, ${unsaved.owner}::int4, ${unsaved.folderflag}::"public"."Flag", ${unsaved.filename}, ${unsaved.fileextension}, ${unsaved.revision}::bpchar, ${unsaved.changenumber}::int4, ${unsaved.status}::int2, ${unsaved.documentsummary}, ${unsaved.document}::bytea, ${unsaved.rowguid}::uuid, ${unsaved.modifieddate}::timestamp, ${unsaved.documentnode})
          returning title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode
       """.query.unique
  }
  override def insert(unsaved: DocumentRowUnsaved): ConnectionIO[DocumentRow] = {
    val fs = List(
      Some((Fragment.const(s"title"), fr"${unsaved.title}")),
      Some((Fragment.const(s""""owner""""), fr"${unsaved.owner}::int4")),
      Some((Fragment.const(s"filename"), fr"${unsaved.filename}")),
      Some((Fragment.const(s"fileextension"), fr"${unsaved.fileextension}")),
      Some((Fragment.const(s"revision"), fr"${unsaved.revision}::bpchar")),
      Some((Fragment.const(s"status"), fr"${unsaved.status}::int2")),
      Some((Fragment.const(s"documentsummary"), fr"${unsaved.documentsummary}")),
      Some((Fragment.const(s""""document""""), fr"${unsaved.document}::bytea")),
      unsaved.folderflag match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"folderflag"), fr"""${value: Flag}::"public"."Flag""""))
      },
      unsaved.changenumber match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"changenumber"), fr"${value: Int}::int4"))
      },
      unsaved.rowguid match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"rowguid"), fr"${value: UUID}::uuid"))
      },
      unsaved.modifieddate match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"modifieddate"), fr"${value: LocalDateTime}::timestamp"))
      },
      unsaved.documentnode match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"documentnode"), fr"${value: DocumentId}"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into production."document" default values
            returning title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode
         """
    } else {
      import cats.syntax.foldable.toFoldableOps
      sql"""insert into production."document"(${fs.map { case (n, _) => n }.intercalate(fr", ")})
            values (${fs.map { case (_, f) => f }.intercalate(fr", ")})
            returning title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode
         """
    }
    q.query.unique
  
  }
  override def selectAll: Stream[ConnectionIO, DocumentRow] = {
    sql"""select title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode from production."document"""".query[DocumentRow].stream
  }
  override def selectByFieldValues(fieldValues: List[DocumentFieldOrIdValue[_]]): Stream[ConnectionIO, DocumentRow] = {
    val where = fragments.whereAnd(
      fieldValues.map {
        case DocumentFieldValue.title(value) => fr"title = $value"
        case DocumentFieldValue.owner(value) => fr""""owner" = $value"""
        case DocumentFieldValue.folderflag(value) => fr"folderflag = $value"
        case DocumentFieldValue.filename(value) => fr"filename = $value"
        case DocumentFieldValue.fileextension(value) => fr"fileextension = $value"
        case DocumentFieldValue.revision(value) => fr"revision = $value"
        case DocumentFieldValue.changenumber(value) => fr"changenumber = $value"
        case DocumentFieldValue.status(value) => fr"status = $value"
        case DocumentFieldValue.documentsummary(value) => fr"documentsummary = $value"
        case DocumentFieldValue.document(value) => fr""""document" = $value"""
        case DocumentFieldValue.rowguid(value) => fr"rowguid = $value"
        case DocumentFieldValue.modifieddate(value) => fr"modifieddate = $value"
        case DocumentFieldValue.documentnode(value) => fr"documentnode = $value"
      } :_*
    )
    sql"""select * from production."document" $where""".query[DocumentRow].stream
  
  }
  override def selectById(documentnode: DocumentId): ConnectionIO[Option[DocumentRow]] = {
    sql"""select title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode from production."document" where documentnode = $documentnode""".query[DocumentRow].option
  }
  override def selectByIds(documentnodes: Array[DocumentId]): Stream[ConnectionIO, DocumentRow] = {
    sql"""select title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode from production."document" where documentnode = ANY($documentnodes)""".query[DocumentRow].stream
  }
  override def selectByUnique(rowguid: UUID): ConnectionIO[Option[DocumentRow]] = {
    selectByFieldValues(List(DocumentFieldValue.rowguid(rowguid))).compile.last
  }
  override def update(row: DocumentRow): ConnectionIO[Boolean] = {
    val documentnode = row.documentnode
    sql"""update production."document"
          set title = ${row.title},
              "owner" = ${row.owner}::int4,
              folderflag = ${row.folderflag}::"public"."Flag",
              filename = ${row.filename},
              fileextension = ${row.fileextension},
              revision = ${row.revision}::bpchar,
              changenumber = ${row.changenumber}::int4,
              status = ${row.status}::int2,
              documentsummary = ${row.documentsummary},
              "document" = ${row.document}::bytea,
              rowguid = ${row.rowguid}::uuid,
              modifieddate = ${row.modifieddate}::timestamp
          where documentnode = $documentnode
       """
      .update
      .run
      .map(_ > 0)
  }
  override def updateFieldValues(documentnode: DocumentId, fieldValues: List[DocumentFieldValue[_]]): ConnectionIO[Boolean] = {
    fieldValues match {
      case Nil => pure(false)
      case nonEmpty =>
        val updates = fragments.set(
          nonEmpty.map {
            case DocumentFieldValue.title(value) => fr"title = $value"
            case DocumentFieldValue.owner(value) => fr""""owner" = $value"""
            case DocumentFieldValue.folderflag(value) => fr"folderflag = $value"
            case DocumentFieldValue.filename(value) => fr"filename = $value"
            case DocumentFieldValue.fileextension(value) => fr"fileextension = $value"
            case DocumentFieldValue.revision(value) => fr"revision = $value"
            case DocumentFieldValue.changenumber(value) => fr"changenumber = $value"
            case DocumentFieldValue.status(value) => fr"status = $value"
            case DocumentFieldValue.documentsummary(value) => fr"documentsummary = $value"
            case DocumentFieldValue.document(value) => fr""""document" = $value"""
            case DocumentFieldValue.rowguid(value) => fr"rowguid = $value"
            case DocumentFieldValue.modifieddate(value) => fr"modifieddate = $value"
          } :_*
        )
        sql"""update production."document"
              $updates
              where documentnode = $documentnode
           """.update.run.map(_ > 0)
    }
  }
  override def upsert(unsaved: DocumentRow): ConnectionIO[DocumentRow] = {
    sql"""insert into production."document"(title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode)
          values (
            ${unsaved.title},
            ${unsaved.owner}::int4,
            ${unsaved.folderflag}::"public"."Flag",
            ${unsaved.filename},
            ${unsaved.fileextension},
            ${unsaved.revision}::bpchar,
            ${unsaved.changenumber}::int4,
            ${unsaved.status}::int2,
            ${unsaved.documentsummary},
            ${unsaved.document}::bytea,
            ${unsaved.rowguid}::uuid,
            ${unsaved.modifieddate}::timestamp,
            ${unsaved.documentnode}
          )
          on conflict (documentnode)
          do update set
            title = EXCLUDED.title,
            "owner" = EXCLUDED."owner",
            folderflag = EXCLUDED.folderflag,
            filename = EXCLUDED.filename,
            fileextension = EXCLUDED.fileextension,
            revision = EXCLUDED.revision,
            changenumber = EXCLUDED.changenumber,
            status = EXCLUDED.status,
            documentsummary = EXCLUDED.documentsummary,
            "document" = EXCLUDED."document",
            rowguid = EXCLUDED.rowguid,
            modifieddate = EXCLUDED.modifieddate
          returning title, "owner", folderflag, filename, fileextension, revision, changenumber, status, documentsummary, "document", rowguid, modifieddate, documentnode
       """.query.unique
  }
  implicit val read: Read[DocumentRow] =
    new Read[DocumentRow](
      gets = List(
        (Get[String], Nullability.NoNulls),
        (Get[BusinessentityId], Nullability.NoNulls),
        (Get[Flag], Nullability.NoNulls),
        (Get[String], Nullability.NoNulls),
        (Get[String], Nullability.Nullable),
        (Get[/* bpchar */ String], Nullability.NoNulls),
        (Get[Int], Nullability.NoNulls),
        (Get[Int], Nullability.NoNulls),
        (Get[String], Nullability.Nullable),
        (Get[Array[Byte]], Nullability.Nullable),
        (Get[UUID], Nullability.NoNulls),
        (Get[LocalDateTime], Nullability.NoNulls),
        (Get[DocumentId], Nullability.NoNulls)
      ),
      unsafeGet = (rs: ResultSet, i: Int) => DocumentRow(
        title = Get[String].unsafeGetNonNullable(rs, i + 0),
        owner = Get[BusinessentityId].unsafeGetNonNullable(rs, i + 1),
        folderflag = Get[Flag].unsafeGetNonNullable(rs, i + 2),
        filename = Get[String].unsafeGetNonNullable(rs, i + 3),
        fileextension = Get[String].unsafeGetNullable(rs, i + 4),
        revision = Get[/* bpchar */ String].unsafeGetNonNullable(rs, i + 5),
        changenumber = Get[Int].unsafeGetNonNullable(rs, i + 6),
        status = Get[Int].unsafeGetNonNullable(rs, i + 7),
        documentsummary = Get[String].unsafeGetNullable(rs, i + 8),
        document = Get[Array[Byte]].unsafeGetNullable(rs, i + 9),
        rowguid = Get[UUID].unsafeGetNonNullable(rs, i + 10),
        modifieddate = Get[LocalDateTime].unsafeGetNonNullable(rs, i + 11),
        documentnode = Get[DocumentId].unsafeGetNonNullable(rs, i + 12)
      )
    )
  

}
