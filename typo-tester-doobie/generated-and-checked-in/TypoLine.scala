/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks

import cats.data.NonEmptyList
import doobie.Get
import doobie.Put
import io.circe.Decoder
import io.circe.Encoder
import io.circe.HCursor
import io.circe.Json
import org.postgresql.geometric.PGline

/** This implements a line represented by the linear equation Ax + By + C = 0 */
case class TypoLine(a: Double, b: Double, c: Double)
object TypoLine {
  implicit val decoder: Decoder[TypoLine] =
    (c: HCursor) =>
      for {
        a <- c.downField("a").as[Double]
        b <- c.downField("b").as[Double]
        c <- c.downField("c").as[Double]
      } yield TypoLine(a, b, c)
  implicit val encoder: Encoder[TypoLine] = {
    import io.circe.syntax._
    row =>
      Json.obj(
        "a" := row.a,
        "b" := row.b,
        "c" := row.c
      )}
  implicit val TypoLineGet: Get[TypoLine] =
    Get.Advanced.other[PGline](cats.data.NonEmptyList.one("line"))
      .map(v => TypoLine(v.a, v.b, v.c))
  
  implicit val TypoLinePut: Put[TypoLine] =
    Put.Advanced.other[PGline](NonEmptyList.one("line"))
      .contramap(v => new PGline(v.a, v.b, v.c))
  
  implicit val TypoLineGetArray: Get[Array[TypoLine]] =
    Get.Advanced.array[AnyRef](NonEmptyList.one("_line"))
      .map(_.map(v => TypoLine(v.asInstanceOf[PGline].a, v.asInstanceOf[PGline].b, v.asInstanceOf[PGline].c)))
  
  implicit val TypoLinePutArray: Put[Array[TypoLine]] =
    Put.Advanced.array[AnyRef](NonEmptyList.one("_line"), "line")
      .contramap(_.map(v => new PGline(v.a, v.b, v.c)))

}
