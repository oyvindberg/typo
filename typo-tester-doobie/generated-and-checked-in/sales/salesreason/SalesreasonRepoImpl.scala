/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package sales
package salesreason

import adventureworks.Defaulted
import adventureworks.public.Name
import doobie.Get
import doobie.Read
import doobie.enumerated.Nullability
import doobie.free.connection.ConnectionIO
import doobie.free.connection.pure
import doobie.syntax.string.toSqlInterpolator
import doobie.util.fragment.Fragment
import doobie.util.fragments
import fs2.Stream
import java.sql.ResultSet
import java.time.LocalDateTime

object SalesreasonRepoImpl extends SalesreasonRepo {
  override def delete(salesreasonid: SalesreasonId): ConnectionIO[Boolean] = {
    sql"delete from sales.salesreason where salesreasonid = $salesreasonid".update.run.map(_ > 0)
  }
  override def insert(unsaved: SalesreasonRow): ConnectionIO[SalesreasonRow] = {
    sql"""insert into sales.salesreason(salesreasonid, "name", reasontype, modifieddate)
          values (${unsaved.salesreasonid}::int4, ${unsaved.name}::"public"."Name", ${unsaved.reasontype}::"public"."Name", ${unsaved.modifieddate}::timestamp)
          returning salesreasonid, "name", reasontype, modifieddate
       """.query.unique
  }
  override def insert(unsaved: SalesreasonRowUnsaved): ConnectionIO[SalesreasonRow] = {
    val fs = List(
      Some((Fragment.const(s""""name""""), fr"""${unsaved.name}::"public"."Name"""")),
      Some((Fragment.const(s"reasontype"), fr"""${unsaved.reasontype}::"public"."Name"""")),
      unsaved.salesreasonid match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"salesreasonid"), fr"${value: SalesreasonId}::int4"))
      },
      unsaved.modifieddate match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"modifieddate"), fr"${value: LocalDateTime}::timestamp"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into sales.salesreason default values
            returning salesreasonid, "name", reasontype, modifieddate
         """
    } else {
      import cats.syntax.foldable.toFoldableOps
      sql"""insert into sales.salesreason(${fs.map { case (n, _) => n }.intercalate(fr", ")})
            values (${fs.map { case (_, f) => f }.intercalate(fr", ")})
            returning salesreasonid, "name", reasontype, modifieddate
         """
    }
    q.query.unique
  
  }
  override def selectAll: Stream[ConnectionIO, SalesreasonRow] = {
    sql"""select salesreasonid, "name", reasontype, modifieddate from sales.salesreason""".query[SalesreasonRow].stream
  }
  override def selectByFieldValues(fieldValues: List[SalesreasonFieldOrIdValue[_]]): Stream[ConnectionIO, SalesreasonRow] = {
    val where = fragments.whereAnd(
      fieldValues.map {
        case SalesreasonFieldValue.salesreasonid(value) => fr"salesreasonid = $value"
        case SalesreasonFieldValue.name(value) => fr""""name" = $value"""
        case SalesreasonFieldValue.reasontype(value) => fr"reasontype = $value"
        case SalesreasonFieldValue.modifieddate(value) => fr"modifieddate = $value"
      } :_*
    )
    sql"select * from sales.salesreason $where".query[SalesreasonRow].stream
  
  }
  override def selectById(salesreasonid: SalesreasonId): ConnectionIO[Option[SalesreasonRow]] = {
    sql"""select salesreasonid, "name", reasontype, modifieddate from sales.salesreason where salesreasonid = $salesreasonid""".query[SalesreasonRow].option
  }
  override def selectByIds(salesreasonids: Array[SalesreasonId]): Stream[ConnectionIO, SalesreasonRow] = {
    sql"""select salesreasonid, "name", reasontype, modifieddate from sales.salesreason where salesreasonid = ANY($salesreasonids)""".query[SalesreasonRow].stream
  }
  override def update(row: SalesreasonRow): ConnectionIO[Boolean] = {
    val salesreasonid = row.salesreasonid
    sql"""update sales.salesreason
          set "name" = ${row.name}::"public"."Name",
              reasontype = ${row.reasontype}::"public"."Name",
              modifieddate = ${row.modifieddate}::timestamp
          where salesreasonid = $salesreasonid
       """
      .update
      .run
      .map(_ > 0)
  }
  override def updateFieldValues(salesreasonid: SalesreasonId, fieldValues: List[SalesreasonFieldValue[_]]): ConnectionIO[Boolean] = {
    fieldValues match {
      case Nil => pure(false)
      case nonEmpty =>
        val updates = fragments.set(
          nonEmpty.map {
            case SalesreasonFieldValue.name(value) => fr""""name" = $value"""
            case SalesreasonFieldValue.reasontype(value) => fr"reasontype = $value"
            case SalesreasonFieldValue.modifieddate(value) => fr"modifieddate = $value"
          } :_*
        )
        sql"""update sales.salesreason
              $updates
              where salesreasonid = $salesreasonid
           """.update.run.map(_ > 0)
    }
  }
  override def upsert(unsaved: SalesreasonRow): ConnectionIO[SalesreasonRow] = {
    sql"""insert into sales.salesreason(salesreasonid, "name", reasontype, modifieddate)
          values (
            ${unsaved.salesreasonid}::int4,
            ${unsaved.name}::"public"."Name",
            ${unsaved.reasontype}::"public"."Name",
            ${unsaved.modifieddate}::timestamp
          )
          on conflict (salesreasonid)
          do update set
            "name" = EXCLUDED."name",
            reasontype = EXCLUDED.reasontype,
            modifieddate = EXCLUDED.modifieddate
          returning salesreasonid, "name", reasontype, modifieddate
       """.query.unique
  }
  implicit val read: Read[SalesreasonRow] =
    new Read[SalesreasonRow](
      gets = List(
        (Get[SalesreasonId], Nullability.NoNulls),
        (Get[Name], Nullability.NoNulls),
        (Get[Name], Nullability.NoNulls),
        (Get[LocalDateTime], Nullability.NoNulls)
      ),
      unsafeGet = (rs: ResultSet, i: Int) => SalesreasonRow(
        salesreasonid = Get[SalesreasonId].unsafeGetNonNullable(rs, i + 0),
        name = Get[Name].unsafeGetNonNullable(rs, i + 1),
        reasontype = Get[Name].unsafeGetNonNullable(rs, i + 2),
        modifieddate = Get[LocalDateTime].unsafeGetNonNullable(rs, i + 3)
      )
    )
  

}
