/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package pg_catalog
package pg_collation

import doobie.free.connection.ConnectionIO
import doobie.syntax.string.toSqlInterpolator
import fs2.Stream

object PgCollationRepoImpl extends PgCollationRepo {
  override def delete(oid: PgCollationId): ConnectionIO[Boolean] = {
    sql"delete from pg_catalog.pg_collation where oid = ${oid}".update.run.map(_ > 0)
  }
  override def insert(unsaved: PgCollationRow): ConnectionIO[PgCollationRow] = {
    sql"""insert into pg_catalog.pg_collation(oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion)
          values (${unsaved.oid}::oid, ${unsaved.collname}::name, ${unsaved.collnamespace}::oid, ${unsaved.collowner}::oid, ${unsaved.collprovider}::char, ${unsaved.collisdeterministic}, ${unsaved.collencoding}::int4, ${unsaved.collcollate}::name, ${unsaved.collctype}::name, ${unsaved.collversion})
          returning oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion
       """.query[PgCollationRow].unique
  }
  override def selectAll: Stream[ConnectionIO, PgCollationRow] = {
    sql"select oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion from pg_catalog.pg_collation".query[PgCollationRow].stream
  }
  override def selectById(oid: PgCollationId): ConnectionIO[Option[PgCollationRow]] = {
    sql"select oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion from pg_catalog.pg_collation where oid = ${oid}".query[PgCollationRow].option
  }
  override def selectByIds(oids: Array[PgCollationId]): Stream[ConnectionIO, PgCollationRow] = {
    sql"select oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion from pg_catalog.pg_collation where oid = ANY(${oids})".query[PgCollationRow].stream
  }
  override def update(row: PgCollationRow): ConnectionIO[Boolean] = {
    val oid = row.oid
    sql"""update pg_catalog.pg_collation
          set collname = ${row.collname}::name,
              collnamespace = ${row.collnamespace}::oid,
              collowner = ${row.collowner}::oid,
              collprovider = ${row.collprovider}::char,
              collisdeterministic = ${row.collisdeterministic},
              collencoding = ${row.collencoding}::int4,
              collcollate = ${row.collcollate}::name,
              collctype = ${row.collctype}::name,
              collversion = ${row.collversion}
          where oid = ${oid}
       """
      .update
      .run
      .map(_ > 0)
  }
  override def upsert(unsaved: PgCollationRow): ConnectionIO[PgCollationRow] = {
    sql"""insert into pg_catalog.pg_collation(oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion)
          values (
            ${unsaved.oid}::oid,
            ${unsaved.collname}::name,
            ${unsaved.collnamespace}::oid,
            ${unsaved.collowner}::oid,
            ${unsaved.collprovider}::char,
            ${unsaved.collisdeterministic},
            ${unsaved.collencoding}::int4,
            ${unsaved.collcollate}::name,
            ${unsaved.collctype}::name,
            ${unsaved.collversion}
          )
          on conflict (oid)
          do update set
            collname = EXCLUDED.collname,
            collnamespace = EXCLUDED.collnamespace,
            collowner = EXCLUDED.collowner,
            collprovider = EXCLUDED.collprovider,
            collisdeterministic = EXCLUDED.collisdeterministic,
            collencoding = EXCLUDED.collencoding,
            collcollate = EXCLUDED.collcollate,
            collctype = EXCLUDED.collctype,
            collversion = EXCLUDED.collversion
          returning oid, collname, collnamespace, collowner, collprovider, collisdeterministic, collencoding, collcollate, collctype, collversion
       """.query[PgCollationRow].unique
  }
}
