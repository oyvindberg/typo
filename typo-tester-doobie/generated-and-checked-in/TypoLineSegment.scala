/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks

import cats.data.NonEmptyList
import doobie.util.Get
import doobie.util.Put
import io.circe.Decoder
import io.circe.Encoder
import org.postgresql.geometric.PGlseg
import org.postgresql.geometric.PGpoint

/** This implements a line represented by the linear equation Ax + By + C = 0 */
case class TypoLineSegment(p1: TypoPoint, p2: TypoPoint)

object TypoLineSegment {
  implicit val arrayGet: Get[Array[TypoLineSegment]] = Get.Advanced.array[AnyRef](NonEmptyList.one("_lseg"))
    .map(_.map(v => TypoLineSegment(TypoPoint(v.asInstanceOf[PGlseg].point(0).x, v.asInstanceOf[PGlseg].point(0).y), TypoPoint(v.asInstanceOf[PGlseg].point(1).x, v.asInstanceOf[PGlseg].point(1).y))))
  implicit val arrayPut: Put[Array[TypoLineSegment]] = Put.Advanced.array[AnyRef](NonEmptyList.one("_lseg"), "lseg")
    .contramap(_.map(v => new PGlseg(new PGpoint(v.p1.x, v.p1.y), new PGpoint(v.p2.x, v.p2.y))))
  implicit val decoder: Decoder[TypoLineSegment] = Decoder.forProduct2[TypoLineSegment, TypoPoint, TypoPoint]("p1", "p2")(TypoLineSegment.apply)(TypoPoint.decoder, TypoPoint.decoder)
  implicit val encoder: Encoder[TypoLineSegment] = Encoder.forProduct2[TypoLineSegment, TypoPoint, TypoPoint]("p1", "p2")(x => (x.p1, x.p2))(TypoPoint.encoder, TypoPoint.encoder)
  implicit val get: Get[TypoLineSegment] = Get.Advanced.other[PGlseg](NonEmptyList.one("lseg"))
    .map(v => TypoLineSegment(TypoPoint(v.point(0).x, v.point(0).y), TypoPoint(v.point(1).x, v.point(1).y)))
  implicit def ordering(implicit O0: Ordering[TypoPoint]): Ordering[TypoLineSegment] = Ordering.by(x => (x.p1, x.p2))
  implicit val put: Put[TypoLineSegment] = Put.Advanced.other[PGlseg](NonEmptyList.one("lseg")).contramap(v => new PGlseg(new PGpoint(v.p1.x, v.p1.y), new PGpoint(v.p2.x, v.p2.y)))
}
