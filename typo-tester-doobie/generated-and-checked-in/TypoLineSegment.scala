/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks

import cats.data.NonEmptyList
import doobie.Get
import doobie.Put
import io.circe.Decoder
import io.circe.Encoder
import io.circe.HCursor
import io.circe.Json
import org.postgresql.geometric.PGlseg
import org.postgresql.geometric.PGpoint

/** This implements a line represented by the linear equation Ax + By + C = 0 */
case class TypoLineSegment(p1: TypoPoint, p2: TypoPoint)
object TypoLineSegment {
  implicit val decoder: Decoder[TypoLineSegment] =
    (c: HCursor) =>
      for {
        p1 <- c.downField("p1").as[TypoPoint]
        p2 <- c.downField("p2").as[TypoPoint]
      } yield TypoLineSegment(p1, p2)
  implicit val encoder: Encoder[TypoLineSegment] = {
    import io.circe.syntax._
    row =>
      Json.obj(
        "p1" := row.p1,
        "p2" := row.p2
      )}
  implicit val TypoLineSegmentGet: Get[TypoLineSegment] =
    Get.Advanced.other[PGlseg](cats.data.NonEmptyList.one("lseg"))
      .map(v => TypoLineSegment(TypoPoint(v.point(0).x, v.point(0).y), TypoPoint(v.point(1).x, v.point(1).y)))
  
  implicit val TypoLineSegmentPut: Put[TypoLineSegment] =
    Put.Advanced.other[PGlseg](NonEmptyList.one("lseg"))
      .contramap(v => new PGlseg(new PGpoint(v.p1.x, v.p1.y), new PGpoint(v.p2.x, v.p2.y)))
  
  implicit val TypoLineSegmentGetArray: Get[Array[TypoLineSegment]] =
    Get.Advanced.array[AnyRef](NonEmptyList.one("_lseg"))
      .map(_.map(v => TypoLineSegment(TypoPoint(v.asInstanceOf[PGlseg].point(0).x, v.asInstanceOf[PGlseg].point(0).y), TypoPoint(v.asInstanceOf[PGlseg].point(1).x, v.asInstanceOf[PGlseg].point(1).y))))
  
  implicit val TypoLineSegmentPutArray: Put[Array[TypoLineSegment]] =
    Put.Advanced.array[AnyRef](NonEmptyList.one("_lseg"), "lseg")
      .contramap(_.map(v => new PGlseg(new PGpoint(v.p1.x, v.p1.y), new PGpoint(v.p2.x, v.p2.y))))

}
