/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks

import anorm.Column
import anorm.ParameterMetaData
import anorm.ToStatement
import anorm.TypeDoesNotMatch
import java.sql.Types
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeFormatterBuilder
import java.time.temporal.ChronoField
import java.time.temporal.ChronoUnit
import org.postgresql.jdbc.PgArray
import play.api.libs.json.JsObject
import play.api.libs.json.JsResult
import play.api.libs.json.JsValue
import play.api.libs.json.OWrites
import play.api.libs.json.Reads
import play.api.libs.json.Writes
import scala.collection.immutable.ListMap
import scala.util.Try

/** This is `java.time.OffsetDateTime`, but with microsecond precision and transferred to and from postgres as strings. The reason is that postgres driver and db libs are broken */
case class TypoOffsetDateTime(value: OffsetDateTime)

object TypoOffsetDateTime {
  val parser: DateTimeFormatter =
    new DateTimeFormatterBuilder().appendPattern("yyyy-MM-dd HH:mm:ss").appendFraction(ChronoField.MICRO_OF_SECOND, 0, 6, true).appendPattern("X").toFormatter
  def apply(value: OffsetDateTime): TypoOffsetDateTime = new TypoOffsetDateTime(value.truncatedTo(ChronoUnit.MICROS))  
  def now = TypoOffsetDateTime(OffsetDateTime.now)
  implicit val arrayColumn: Column[Array[TypoOffsetDateTime]] = Column.nonNull[Array[TypoOffsetDateTime]]((v1: Any, _) =>
    v1 match {
        case v: PgArray =>
         v.getArray match {
           case v: Array[?] =>
             Right(v.map(v => TypoOffsetDateTime(OffsetDateTime.parse(v.asInstanceOf[String], parser))))
           case other => Left(TypeDoesNotMatch(s"Expected one-dimensional array from JDBC to produce an array of TypoOffsetDateTime, got ${other.getClass.getName}"))
         }
      case other => Left(TypeDoesNotMatch(s"Expected instance of org.postgresql.jdbc.PgArray, got ${other.getClass.getName}"))
    }
  )
  implicit val arrayParameterMetaData: ParameterMetaData[Array[TypoOffsetDateTime]] = new ParameterMetaData[Array[TypoOffsetDateTime]] {
    override def sqlType: String = "_text"
    override def jdbcType: Int = Types.ARRAY
  }
  implicit val arrayToStatement: ToStatement[Array[TypoOffsetDateTime]] = ToStatement[Array[TypoOffsetDateTime]]((s, index, v) => s.setArray(index, s.getConnection.createArrayOf("text", v.map(v => v.value.toString))))
  implicit val column: Column[TypoOffsetDateTime] = Column.nonNull[TypoOffsetDateTime]((v1: Any, _) =>
    v1 match {
      case v: String => Right(TypoOffsetDateTime(OffsetDateTime.parse(v, parser)))
      case other => Left(TypeDoesNotMatch(s"Expected instance of java.lang.String, got ${other.getClass.getName}"))
    }
  )
  implicit val parameterMetadata: ParameterMetaData[TypoOffsetDateTime] = new ParameterMetaData[TypoOffsetDateTime] {
    override def sqlType: String = "text"
    override def jdbcType: Int = Types.OTHER
  }
  implicit val reads: Reads[TypoOffsetDateTime] = Reads[TypoOffsetDateTime](json => JsResult.fromTry(
      Try(
        TypoOffsetDateTime(
          value = json.\("value").as(Reads.DefaultOffsetDateTimeReads)
        )
      )
    ),
  )
  implicit val toStatement: ToStatement[TypoOffsetDateTime] = ToStatement[TypoOffsetDateTime]((s, index, v) => s.setObject(index, v.value.toString))
  implicit val writes: OWrites[TypoOffsetDateTime] = OWrites[TypoOffsetDateTime](o =>
    new JsObject(ListMap[String, JsValue](
      "value" -> Writes.DefaultOffsetDateTimeWrites.writes(o.value)
    ))
  )
}
