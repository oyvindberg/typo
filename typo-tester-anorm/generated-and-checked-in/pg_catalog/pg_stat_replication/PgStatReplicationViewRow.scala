/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package pg_catalog
package pg_stat_replication

import adventureworks.TypoInet
import adventureworks.TypoInterval
import adventureworks.TypoXid
import anorm.RowParser
import anorm.Success
import java.time.OffsetDateTime
import play.api.libs.json.JsObject
import play.api.libs.json.JsResult
import play.api.libs.json.JsValue
import play.api.libs.json.Json
import play.api.libs.json.OFormat
import scala.util.Try

case class PgStatReplicationViewRow(
  pid: Option[Int],
  usesysid: Option[/* oid */ Long],
  usename: Option[String],
  applicationName: Option[String],
  clientAddr: Option[TypoInet],
  clientHostname: Option[String],
  clientPort: Option[Int],
  backendStart: Option[OffsetDateTime],
  backendXmin: Option[TypoXid],
  state: Option[String],
  sentLsn: Option[/* pg_lsn */ Long],
  writeLsn: Option[/* pg_lsn */ Long],
  flushLsn: Option[/* pg_lsn */ Long],
  replayLsn: Option[/* pg_lsn */ Long],
  writeLag: Option[TypoInterval],
  flushLag: Option[TypoInterval],
  replayLag: Option[TypoInterval],
  syncPriority: Option[Int],
  syncState: Option[String],
  replyTime: Option[OffsetDateTime]
)

object PgStatReplicationViewRow {
  def rowParser(idx: Int): RowParser[PgStatReplicationViewRow] =
    RowParser[PgStatReplicationViewRow] { row =>
      Success(
        PgStatReplicationViewRow(
          pid = row[Option[Int]](idx + 0),
          usesysid = row[Option[/* oid */ Long]](idx + 1),
          usename = row[Option[String]](idx + 2),
          applicationName = row[Option[String]](idx + 3),
          clientAddr = row[Option[TypoInet]](idx + 4),
          clientHostname = row[Option[String]](idx + 5),
          clientPort = row[Option[Int]](idx + 6),
          backendStart = row[Option[OffsetDateTime]](idx + 7),
          backendXmin = row[Option[TypoXid]](idx + 8),
          state = row[Option[String]](idx + 9),
          sentLsn = row[Option[/* pg_lsn */ Long]](idx + 10),
          writeLsn = row[Option[/* pg_lsn */ Long]](idx + 11),
          flushLsn = row[Option[/* pg_lsn */ Long]](idx + 12),
          replayLsn = row[Option[/* pg_lsn */ Long]](idx + 13),
          writeLag = row[Option[TypoInterval]](idx + 14),
          flushLag = row[Option[TypoInterval]](idx + 15),
          replayLag = row[Option[TypoInterval]](idx + 16),
          syncPriority = row[Option[Int]](idx + 17),
          syncState = row[Option[String]](idx + 18),
          replyTime = row[Option[OffsetDateTime]](idx + 19)
        )
      )
    }
  implicit val oFormat: OFormat[PgStatReplicationViewRow] = new OFormat[PgStatReplicationViewRow]{
    override def writes(o: PgStatReplicationViewRow): JsObject =
      Json.obj(
        "pid" -> o.pid,
        "usesysid" -> o.usesysid,
        "usename" -> o.usename,
        "application_name" -> o.applicationName,
        "client_addr" -> o.clientAddr,
        "client_hostname" -> o.clientHostname,
        "client_port" -> o.clientPort,
        "backend_start" -> o.backendStart,
        "backend_xmin" -> o.backendXmin,
        "state" -> o.state,
        "sent_lsn" -> o.sentLsn,
        "write_lsn" -> o.writeLsn,
        "flush_lsn" -> o.flushLsn,
        "replay_lsn" -> o.replayLsn,
        "write_lag" -> o.writeLag,
        "flush_lag" -> o.flushLag,
        "replay_lag" -> o.replayLag,
        "sync_priority" -> o.syncPriority,
        "sync_state" -> o.syncState,
        "reply_time" -> o.replyTime
      )
  
    override def reads(json: JsValue): JsResult[PgStatReplicationViewRow] = {
      JsResult.fromTry(
        Try(
          PgStatReplicationViewRow(
            pid = json.\("pid").toOption.map(_.as[Int]),
            usesysid = json.\("usesysid").toOption.map(_.as[/* oid */ Long]),
            usename = json.\("usename").toOption.map(_.as[String]),
            applicationName = json.\("application_name").toOption.map(_.as[String]),
            clientAddr = json.\("client_addr").toOption.map(_.as[TypoInet]),
            clientHostname = json.\("client_hostname").toOption.map(_.as[String]),
            clientPort = json.\("client_port").toOption.map(_.as[Int]),
            backendStart = json.\("backend_start").toOption.map(_.as[OffsetDateTime]),
            backendXmin = json.\("backend_xmin").toOption.map(_.as[TypoXid]),
            state = json.\("state").toOption.map(_.as[String]),
            sentLsn = json.\("sent_lsn").toOption.map(_.as[/* pg_lsn */ Long]),
            writeLsn = json.\("write_lsn").toOption.map(_.as[/* pg_lsn */ Long]),
            flushLsn = json.\("flush_lsn").toOption.map(_.as[/* pg_lsn */ Long]),
            replayLsn = json.\("replay_lsn").toOption.map(_.as[/* pg_lsn */ Long]),
            writeLag = json.\("write_lag").toOption.map(_.as[TypoInterval]),
            flushLag = json.\("flush_lag").toOption.map(_.as[TypoInterval]),
            replayLag = json.\("replay_lag").toOption.map(_.as[TypoInterval]),
            syncPriority = json.\("sync_priority").toOption.map(_.as[Int]),
            syncState = json.\("sync_state").toOption.map(_.as[String]),
            replyTime = json.\("reply_time").toOption.map(_.as[OffsetDateTime])
          )
        )
      )
    }
  }
}
