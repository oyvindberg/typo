/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package pg_catalog
package pg_sequences

import adventureworks.TypoRegtype
import anorm.Column
import anorm.RowParser
import anorm.Success
import play.api.libs.json.JsObject
import play.api.libs.json.JsResult
import play.api.libs.json.JsValue
import play.api.libs.json.OWrites
import play.api.libs.json.Reads
import play.api.libs.json.Writes
import scala.collection.immutable.ListMap
import scala.util.Try

case class PgSequencesViewRow(
  schemaname: Option[String],
  sequencename: Option[String],
  sequenceowner: Option[String],
  dataType: Option[TypoRegtype],
  startValue: Option[Long],
  minValue: Option[Long],
  maxValue: Option[Long],
  incrementBy: Option[Long],
  cycle: Option[Boolean],
  cacheSize: Option[Long],
  lastValue: Option[Long]
)

object PgSequencesViewRow {
  implicit val reads: Reads[PgSequencesViewRow] = Reads[PgSequencesViewRow](json => JsResult.fromTry(
      Try(
        PgSequencesViewRow(
          schemaname = json.\("schemaname").toOption.map(_.as(Reads.StringReads)),
          sequencename = json.\("sequencename").toOption.map(_.as(Reads.StringReads)),
          sequenceowner = json.\("sequenceowner").toOption.map(_.as(Reads.StringReads)),
          dataType = json.\("data_type").toOption.map(_.as(TypoRegtype.reads)),
          startValue = json.\("start_value").toOption.map(_.as(Reads.LongReads)),
          minValue = json.\("min_value").toOption.map(_.as(Reads.LongReads)),
          maxValue = json.\("max_value").toOption.map(_.as(Reads.LongReads)),
          incrementBy = json.\("increment_by").toOption.map(_.as(Reads.LongReads)),
          cycle = json.\("cycle").toOption.map(_.as(Reads.BooleanReads)),
          cacheSize = json.\("cache_size").toOption.map(_.as(Reads.LongReads)),
          lastValue = json.\("last_value").toOption.map(_.as(Reads.LongReads))
        )
      )
    ),
  )
  def rowParser(idx: Int): RowParser[PgSequencesViewRow] = RowParser[PgSequencesViewRow] { row =>
    Success(
      PgSequencesViewRow(
        schemaname = row(idx + 0)(Column.columnToOption(Column.columnToString)),
        sequencename = row(idx + 1)(Column.columnToOption(Column.columnToString)),
        sequenceowner = row(idx + 2)(Column.columnToOption(Column.columnToString)),
        dataType = row(idx + 3)(Column.columnToOption(TypoRegtype.column)),
        startValue = row(idx + 4)(Column.columnToOption(Column.columnToLong)),
        minValue = row(idx + 5)(Column.columnToOption(Column.columnToLong)),
        maxValue = row(idx + 6)(Column.columnToOption(Column.columnToLong)),
        incrementBy = row(idx + 7)(Column.columnToOption(Column.columnToLong)),
        cycle = row(idx + 8)(Column.columnToOption(Column.columnToBoolean)),
        cacheSize = row(idx + 9)(Column.columnToOption(Column.columnToLong)),
        lastValue = row(idx + 10)(Column.columnToOption(Column.columnToLong))
      )
    )
  }
  implicit val writes: OWrites[PgSequencesViewRow] = OWrites[PgSequencesViewRow](o =>
    new JsObject(ListMap[String, JsValue](
      "schemaname" -> Writes.OptionWrites(Writes.StringWrites).writes(o.schemaname),
      "sequencename" -> Writes.OptionWrites(Writes.StringWrites).writes(o.sequencename),
      "sequenceowner" -> Writes.OptionWrites(Writes.StringWrites).writes(o.sequenceowner),
      "data_type" -> Writes.OptionWrites(TypoRegtype.writes).writes(o.dataType),
      "start_value" -> Writes.OptionWrites(Writes.LongWrites).writes(o.startValue),
      "min_value" -> Writes.OptionWrites(Writes.LongWrites).writes(o.minValue),
      "max_value" -> Writes.OptionWrites(Writes.LongWrites).writes(o.maxValue),
      "increment_by" -> Writes.OptionWrites(Writes.LongWrites).writes(o.incrementBy),
      "cycle" -> Writes.OptionWrites(Writes.BooleanWrites).writes(o.cycle),
      "cache_size" -> Writes.OptionWrites(Writes.LongWrites).writes(o.cacheSize),
      "last_value" -> Writes.OptionWrites(Writes.LongWrites).writes(o.lastValue)
    ))
  )
}
