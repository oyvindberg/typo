/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package pg_catalog
package pg_database

import anorm.Column
import anorm.RowParser
import anorm.Success
import play.api.libs.json.JsObject
import play.api.libs.json.JsResult
import play.api.libs.json.JsValue
import play.api.libs.json.OWrites
import play.api.libs.json.Reads
import play.api.libs.json.Writes
import scala.collection.immutable.ListMap
import scala.util.Try

case class PgDatabaseRow(
  oid: PgDatabaseId,
  datname: String,
  datdba: /* oid */ Long,
  encoding: Int,
  datcollate: String,
  datctype: String,
  datistemplate: Boolean,
  datallowconn: Boolean,
  datconnlimit: Int,
  datlastsysoid: /* oid */ Long,
  datfrozenxid: TypoXid,
  datminmxid: TypoXid,
  dattablespace: /* oid */ Long,
  datacl: Option[Array[TypoAclItem]]
)

object PgDatabaseRow {
  implicit lazy val reads: Reads[PgDatabaseRow] = Reads[PgDatabaseRow](json => JsResult.fromTry(
      Try(
        PgDatabaseRow(
          oid = json.\("oid").as(PgDatabaseId.reads),
          datname = json.\("datname").as(Reads.StringReads),
          datdba = json.\("datdba").as(Reads.LongReads),
          encoding = json.\("encoding").as(Reads.IntReads),
          datcollate = json.\("datcollate").as(Reads.StringReads),
          datctype = json.\("datctype").as(Reads.StringReads),
          datistemplate = json.\("datistemplate").as(Reads.BooleanReads),
          datallowconn = json.\("datallowconn").as(Reads.BooleanReads),
          datconnlimit = json.\("datconnlimit").as(Reads.IntReads),
          datlastsysoid = json.\("datlastsysoid").as(Reads.LongReads),
          datfrozenxid = json.\("datfrozenxid").as(TypoXid.reads),
          datminmxid = json.\("datminmxid").as(TypoXid.reads),
          dattablespace = json.\("dattablespace").as(Reads.LongReads),
          datacl = json.\("datacl").toOption.map(_.as(Reads.ArrayReads[TypoAclItem](TypoAclItem.reads, implicitly)))
        )
      )
    ),
  )
  def rowParser(idx: Int): RowParser[PgDatabaseRow] = RowParser[PgDatabaseRow] { row =>
    Success(
      PgDatabaseRow(
        oid = row(idx + 0)(PgDatabaseId.column),
        datname = row(idx + 1)(Column.columnToString),
        datdba = row(idx + 2)(Column.columnToLong),
        encoding = row(idx + 3)(Column.columnToInt),
        datcollate = row(idx + 4)(Column.columnToString),
        datctype = row(idx + 5)(Column.columnToString),
        datistemplate = row(idx + 6)(Column.columnToBoolean),
        datallowconn = row(idx + 7)(Column.columnToBoolean),
        datconnlimit = row(idx + 8)(Column.columnToInt),
        datlastsysoid = row(idx + 9)(Column.columnToLong),
        datfrozenxid = row(idx + 10)(TypoXid.column),
        datminmxid = row(idx + 11)(TypoXid.column),
        dattablespace = row(idx + 12)(Column.columnToLong),
        datacl = row(idx + 13)(Column.columnToOption(TypoAclItem.arrayColumn))
      )
    )
  }
  implicit lazy val writes: OWrites[PgDatabaseRow] = OWrites[PgDatabaseRow](o =>
    new JsObject(ListMap[String, JsValue](
      "oid" -> PgDatabaseId.writes.writes(o.oid),
      "datname" -> Writes.StringWrites.writes(o.datname),
      "datdba" -> Writes.LongWrites.writes(o.datdba),
      "encoding" -> Writes.IntWrites.writes(o.encoding),
      "datcollate" -> Writes.StringWrites.writes(o.datcollate),
      "datctype" -> Writes.StringWrites.writes(o.datctype),
      "datistemplate" -> Writes.BooleanWrites.writes(o.datistemplate),
      "datallowconn" -> Writes.BooleanWrites.writes(o.datallowconn),
      "datconnlimit" -> Writes.IntWrites.writes(o.datconnlimit),
      "datlastsysoid" -> Writes.LongWrites.writes(o.datlastsysoid),
      "datfrozenxid" -> TypoXid.writes.writes(o.datfrozenxid),
      "datminmxid" -> TypoXid.writes.writes(o.datminmxid),
      "dattablespace" -> Writes.LongWrites.writes(o.dattablespace),
      "datacl" -> Writes.OptionWrites(Writes.arrayWrites[TypoAclItem](implicitly, TypoAclItem.writes)).writes(o.datacl)
    ))
  )
}
