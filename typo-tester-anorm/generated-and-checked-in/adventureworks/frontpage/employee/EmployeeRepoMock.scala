/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks
package frontpage
package employee

import adventureworks.frontpage.person.PersonId
import java.sql.Connection
import scala.annotation.nowarn
import typo.dsl.DeleteBuilder
import typo.dsl.DeleteBuilder.DeleteBuilderMock
import typo.dsl.DeleteParams
import typo.dsl.SelectBuilder
import typo.dsl.SelectBuilderMock
import typo.dsl.SelectParams
import typo.dsl.UpdateBuilder
import typo.dsl.UpdateBuilder.UpdateBuilderMock
import typo.dsl.UpdateParams

class EmployeeRepoMock(toRow: Function1[EmployeeRowUnsaved, EmployeeRow],
                       map: scala.collection.mutable.Map[EmployeeId, EmployeeRow] = scala.collection.mutable.Map.empty) extends EmployeeRepo {
  override def delete: DeleteBuilder[EmployeeFields, EmployeeRow] = {
    DeleteBuilderMock(DeleteParams.empty, EmployeeFields.structure, map)
  }
  override def deleteById(id: EmployeeId)(implicit c: Connection): Boolean = {
    map.remove(id).isDefined
  }
  override def deleteByIds(ids: Array[EmployeeId])(implicit c: Connection): Int = {
    ids.map(id => map.remove(id)).count(_.isDefined)
  }
  override def insert(unsaved: EmployeeRow)(implicit c: Connection): EmployeeRow = {
    val _ = if (map.contains(unsaved.id))
      sys.error(s"id ${unsaved.id} already exists")
    else
      map.put(unsaved.id, unsaved)
    
    unsaved
  }
  override def insert(unsaved: EmployeeRowUnsaved)(implicit c: Connection): EmployeeRow = {
    insert(toRow(unsaved))
  }
  override def insertStreaming(unsaved: Iterator[EmployeeRow], batchSize: Int = 10000)(implicit c: Connection): Long = {
    unsaved.foreach { row =>
      map += (row.id -> row)
    }
    unsaved.size.toLong
  }
  /* NOTE: this functionality requires PostgreSQL 16 or later! */
  override def insertUnsavedStreaming(unsaved: Iterator[EmployeeRowUnsaved], batchSize: Int = 10000)(implicit c: Connection): Long = {
    unsaved.foreach { unsavedRow =>
      val row = toRow(unsavedRow)
      map += (row.id -> row)
    }
    unsaved.size.toLong
  }
  override def select: SelectBuilder[EmployeeFields, EmployeeRow] = {
    SelectBuilderMock(EmployeeFields.structure, () => map.values.toList, SelectParams.empty)
  }
  override def selectAll(implicit c: Connection): List[EmployeeRow] = {
    map.values.toList
  }
  override def selectById(id: EmployeeId)(implicit c: Connection): Option[EmployeeRow] = {
    map.get(id)
  }
  override def selectByIds(ids: Array[EmployeeId])(implicit c: Connection): List[EmployeeRow] = {
    ids.flatMap(map.get).toList
  }
  override def selectByIdsTracked(ids: Array[EmployeeId])(implicit c: Connection): Map[EmployeeId, EmployeeRow] = {
    val byId = selectByIds(ids).view.map(x => (x.id, x)).toMap
    ids.view.flatMap(id => byId.get(id).map(x => (id, x))).toMap
  }
  override def selectByUniquePersonId(personId: PersonId)(implicit c: Connection): Option[EmployeeRow] = {
    map.values.find(v => personId == v.personId)
  }
  override def update: UpdateBuilder[EmployeeFields, EmployeeRow] = {
    UpdateBuilderMock(UpdateParams.empty, EmployeeFields.structure, map)
  }
  override def update(row: EmployeeRow)(implicit c: Connection): Boolean = {
    map.get(row.id) match {
      case Some(`row`) => false
      case Some(_) =>
        map.put(row.id, row): @nowarn
        true
      case None => false
    }
  }
  override def upsert(unsaved: EmployeeRow)(implicit c: Connection): EmployeeRow = {
    map.put(unsaved.id, unsaved): @nowarn
    unsaved
  }
  override def upsertBatch(unsaved: Iterable[EmployeeRow])(implicit c: Connection): List[EmployeeRow] = {
    unsaved.map { row =>
      map += (row.id -> row)
      row
    }.toList
  }
  /* NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override def upsertStreaming(unsaved: Iterator[EmployeeRow], batchSize: Int = 10000)(implicit c: Connection): Int = {
    unsaved.foreach { row =>
      map += (row.id -> row)
    }
    unsaved.size
  }
}
