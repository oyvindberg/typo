/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb
package hardcoded
package myschema
package person

import doobie.Get
import doobie.Read
import doobie.enumerated.Nullability
import doobie.free.connection.ConnectionIO
import doobie.free.connection.pure
import doobie.syntax.string.toSqlInterpolator
import doobie.util.fragment.Fragment
import doobie.util.fragments
import fs2.Stream
import java.sql.ResultSet
import testdb.hardcoded.Defaulted
import testdb.hardcoded.myschema.Sector
import testdb.hardcoded.myschema.football_club.FootballClubId
import testdb.hardcoded.myschema.marital_status.MaritalStatusId

object PersonRepoImpl extends PersonRepo {
  override def delete(id: PersonId): ConnectionIO[Boolean] = {
    sql"""delete from myschema.person where "id" = $id""".update.run.map(_ > 0)
  }
  override def insert(unsaved: PersonRow): ConnectionIO[PersonRow] = {
    sql"""insert into myschema.person("id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector)
          values (${unsaved.id}::int8, ${unsaved.favouriteFootballClubId}, ${unsaved.name}, ${unsaved.nickName}, ${unsaved.blogUrl}, ${unsaved.email}, ${unsaved.phone}, ${unsaved.likesPizza}, ${unsaved.maritalStatusId}, ${unsaved.workEmail}, ${unsaved.sector}::myschema.sector)
          returning "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector
       """.query.unique
  }
  override def insert(unsaved: PersonRowUnsaved): ConnectionIO[PersonRow] = {
    val fs = List(
      Some((Fragment.const(s"favourite_football_club_id"), fr"${unsaved.favouriteFootballClubId}")),
      Some((Fragment.const(s""""name""""), fr"${unsaved.name}")),
      Some((Fragment.const(s"nick_name"), fr"${unsaved.nickName}")),
      Some((Fragment.const(s"blog_url"), fr"${unsaved.blogUrl}")),
      Some((Fragment.const(s"email"), fr"${unsaved.email}")),
      Some((Fragment.const(s"phone"), fr"${unsaved.phone}")),
      Some((Fragment.const(s"likes_pizza"), fr"${unsaved.likesPizza}")),
      Some((Fragment.const(s"work_email"), fr"${unsaved.workEmail}")),
      unsaved.id match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s""""id""""), fr"${value: PersonId}::int8"))
      },
      unsaved.maritalStatusId match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"marital_status_id"), fr"${value: MaritalStatusId}"))
      },
      unsaved.sector match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"sector"), fr"${value: Sector}::myschema.sector"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into myschema.person default values
            returning "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector
         """
    } else {
      import cats.syntax.foldable.toFoldableOps
      sql"""insert into myschema.person(${fs.map { case (n, _) => n }.intercalate(fr", ")})
            values (${fs.map { case (_, f) => f }.intercalate(fr", ")})
            returning "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector
         """
    }
    q.query.unique
  
  }
  override def selectAll: Stream[ConnectionIO, PersonRow] = {
    sql"""select "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector from myschema.person""".query[PersonRow].stream
  }
  override def selectByFieldValues(fieldValues: List[PersonFieldOrIdValue[_]]): Stream[ConnectionIO, PersonRow] = {
    val where = fragments.whereAnd(
      fieldValues.map {
        case PersonFieldValue.id(value) => fr""""id" = $value"""
        case PersonFieldValue.favouriteFootballClubId(value) => fr"favourite_football_club_id = $value"
        case PersonFieldValue.name(value) => fr""""name" = $value"""
        case PersonFieldValue.nickName(value) => fr"nick_name = $value"
        case PersonFieldValue.blogUrl(value) => fr"blog_url = $value"
        case PersonFieldValue.email(value) => fr"email = $value"
        case PersonFieldValue.phone(value) => fr"phone = $value"
        case PersonFieldValue.likesPizza(value) => fr"likes_pizza = $value"
        case PersonFieldValue.maritalStatusId(value) => fr"marital_status_id = $value"
        case PersonFieldValue.workEmail(value) => fr"work_email = $value"
        case PersonFieldValue.sector(value) => fr"sector = $value"
      } :_*
    )
    sql"select * from myschema.person $where".query[PersonRow].stream
  
  }
  override def selectById(id: PersonId): ConnectionIO[Option[PersonRow]] = {
    sql"""select "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector from myschema.person where "id" = $id""".query[PersonRow].option
  }
  override def selectByIds(ids: Array[PersonId]): Stream[ConnectionIO, PersonRow] = {
    sql"""select "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector from myschema.person where "id" = ANY($ids)""".query[PersonRow].stream
  }
  override def update(row: PersonRow): ConnectionIO[Boolean] = {
    val id = row.id
    sql"""update myschema.person
          set favourite_football_club_id = ${row.favouriteFootballClubId},
              "name" = ${row.name},
              nick_name = ${row.nickName},
              blog_url = ${row.blogUrl},
              email = ${row.email},
              phone = ${row.phone},
              likes_pizza = ${row.likesPizza},
              marital_status_id = ${row.maritalStatusId},
              work_email = ${row.workEmail},
              sector = ${row.sector}::myschema.sector
          where "id" = $id
       """
      .update
      .run
      .map(_ > 0)
  }
  override def updateFieldValues(id: PersonId, fieldValues: List[PersonFieldValue[_]]): ConnectionIO[Boolean] = {
    fieldValues match {
      case Nil => pure(false)
      case nonEmpty =>
        val updates = fragments.set(
          nonEmpty.map {
            case PersonFieldValue.favouriteFootballClubId(value) => fr"favourite_football_club_id = $value"
            case PersonFieldValue.name(value) => fr""""name" = $value"""
            case PersonFieldValue.nickName(value) => fr"nick_name = $value"
            case PersonFieldValue.blogUrl(value) => fr"blog_url = $value"
            case PersonFieldValue.email(value) => fr"email = $value"
            case PersonFieldValue.phone(value) => fr"phone = $value"
            case PersonFieldValue.likesPizza(value) => fr"likes_pizza = $value"
            case PersonFieldValue.maritalStatusId(value) => fr"marital_status_id = $value"
            case PersonFieldValue.workEmail(value) => fr"work_email = $value"
            case PersonFieldValue.sector(value) => fr"sector = $value"
          } :_*
        )
        sql"""update myschema.person
              $updates
              where "id" = $id
           """.update.run.map(_ > 0)
    }
  }
  override def upsert(unsaved: PersonRow): ConnectionIO[PersonRow] = {
    sql"""insert into myschema.person("id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector)
          values (
            ${unsaved.id}::int8,
            ${unsaved.favouriteFootballClubId},
            ${unsaved.name},
            ${unsaved.nickName},
            ${unsaved.blogUrl},
            ${unsaved.email},
            ${unsaved.phone},
            ${unsaved.likesPizza},
            ${unsaved.maritalStatusId},
            ${unsaved.workEmail},
            ${unsaved.sector}::myschema.sector
          )
          on conflict ("id")
          do update set
            favourite_football_club_id = EXCLUDED.favourite_football_club_id,
            "name" = EXCLUDED."name",
            nick_name = EXCLUDED.nick_name,
            blog_url = EXCLUDED.blog_url,
            email = EXCLUDED.email,
            phone = EXCLUDED.phone,
            likes_pizza = EXCLUDED.likes_pizza,
            marital_status_id = EXCLUDED.marital_status_id,
            work_email = EXCLUDED.work_email,
            sector = EXCLUDED.sector
          returning "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector
       """.query.unique
  }
  implicit val read: Read[PersonRow] =
    new Read[PersonRow](
      gets = List(
        (Get[PersonId], Nullability.NoNulls),
        (Get[FootballClubId], Nullability.NoNulls),
        (Get[String], Nullability.NoNulls),
        (Get[String], Nullability.Nullable),
        (Get[String], Nullability.Nullable),
        (Get[String], Nullability.NoNulls),
        (Get[String], Nullability.NoNulls),
        (Get[Boolean], Nullability.NoNulls),
        (Get[MaritalStatusId], Nullability.NoNulls),
        (Get[String], Nullability.Nullable),
        (Get[Sector], Nullability.NoNulls)
      ),
      unsafeGet = (rs: ResultSet, i: Int) => PersonRow(
        id = Get[PersonId].unsafeGetNonNullable(rs, i + 0),
        favouriteFootballClubId = Get[FootballClubId].unsafeGetNonNullable(rs, i + 1),
        name = Get[String].unsafeGetNonNullable(rs, i + 2),
        nickName = Get[String].unsafeGetNullable(rs, i + 3),
        blogUrl = Get[String].unsafeGetNullable(rs, i + 4),
        email = Get[String].unsafeGetNonNullable(rs, i + 5),
        phone = Get[String].unsafeGetNonNullable(rs, i + 6),
        likesPizza = Get[Boolean].unsafeGetNonNullable(rs, i + 7),
        maritalStatusId = Get[MaritalStatusId].unsafeGetNonNullable(rs, i + 8),
        workEmail = Get[String].unsafeGetNullable(rs, i + 9),
        sector = Get[Sector].unsafeGetNonNullable(rs, i + 10)
      )
    )
  

}
