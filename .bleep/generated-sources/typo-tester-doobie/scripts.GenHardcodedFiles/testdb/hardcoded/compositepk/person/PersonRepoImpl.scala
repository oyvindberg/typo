/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb
package hardcoded
package compositepk
package person

import doobie.Get
import doobie.Read
import doobie.enumerated.Nullability
import doobie.free.connection.ConnectionIO
import doobie.free.connection.pure
import doobie.syntax.string.toSqlInterpolator
import doobie.util.fragment.Fragment
import doobie.util.fragments
import fs2.Stream
import java.sql.ResultSet
import testdb.hardcoded.Defaulted

object PersonRepoImpl extends PersonRepo {
  override def delete(compositeId: PersonId): ConnectionIO[Boolean] = {
    sql"""delete from compositepk.person where "one" = ${compositeId.one}, two = ${compositeId.two}""".update.run.map(_ > 0)
  }
  override def insert(unsaved: PersonRow): ConnectionIO[PersonRow] = {
    sql"""insert into compositepk.person("one", two, "name")
          values (${unsaved.one}::int8, ${unsaved.two}, ${unsaved.name})
          returning "one", two, "name"
       """.query.unique
  }
  override def insert(unsaved: PersonRowUnsaved): ConnectionIO[PersonRow] = {
    val fs = List(
      Some((Fragment.const(s""""name""""), fr"${unsaved.name}")),
      unsaved.one match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s""""one""""), fr"${value: Long}::int8"))
      },
      unsaved.two match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"two"), fr"${value: Option[String]}"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into compositepk.person default values
            returning "one", two, "name"
         """
    } else {
      import cats.syntax.foldable.toFoldableOps
      sql"""insert into compositepk.person(${fs.map { case (n, _) => n }.intercalate(fr", ")})
            values (${fs.map { case (_, f) => f }.intercalate(fr", ")})
            returning "one", two, "name"
         """
    }
    q.query.unique
  
  }
  override def selectAll: Stream[ConnectionIO, PersonRow] = {
    sql"""select "one", two, "name" from compositepk.person""".query[PersonRow].stream
  }
  override def selectByFieldValues(fieldValues: List[PersonFieldOrIdValue[_]]): Stream[ConnectionIO, PersonRow] = {
    val where = fragments.whereAnd(
      fieldValues.map {
        case PersonFieldValue.one(value) => fr""""one" = $value"""
        case PersonFieldValue.two(value) => fr"two = $value"
        case PersonFieldValue.name(value) => fr""""name" = $value"""
      } :_*
    )
    sql"select * from compositepk.person $where".query[PersonRow].stream
  
  }
  override def selectById(compositeId: PersonId): ConnectionIO[Option[PersonRow]] = {
    sql"""select "one", two, "name" from compositepk.person where "one" = ${compositeId.one}, two = ${compositeId.two}""".query[PersonRow].option
  }
  override def update(row: PersonRow): ConnectionIO[Boolean] = {
    val compositeId = row.compositeId
    sql"""update compositepk.person
          set "name" = ${row.name}
          where "one" = ${compositeId.one}, two = ${compositeId.two}
       """
      .update
      .run
      .map(_ > 0)
  }
  override def updateFieldValues(compositeId: PersonId, fieldValues: List[PersonFieldValue[_]]): ConnectionIO[Boolean] = {
    fieldValues match {
      case Nil => pure(false)
      case nonEmpty =>
        val updates = fragments.set(
          nonEmpty.map {
            case PersonFieldValue.name(value) => fr""""name" = $value"""
          } :_*
        )
        sql"""update compositepk.person
              $updates
              where "one" = ${compositeId.one}, two = ${compositeId.two}
           """.update.run.map(_ > 0)
    }
  }
  override def upsert(unsaved: PersonRow): ConnectionIO[PersonRow] = {
    sql"""insert into compositepk.person("one", two, "name")
          values (
            ${unsaved.one}::int8,
            ${unsaved.two},
            ${unsaved.name}
          )
          on conflict ("one", two)
          do update set
            "name" = EXCLUDED."name"
          returning "one", two, "name"
       """.query.unique
  }
  implicit val read: Read[PersonRow] =
    new Read[PersonRow](
      gets = List(
        (Get[Long], Nullability.NoNulls),
        (Get[String], Nullability.Nullable),
        (Get[String], Nullability.Nullable)
      ),
      unsafeGet = (rs: ResultSet, i: Int) => PersonRow(
        one = Get[Long].unsafeGetNonNullable(rs, i + 0),
        two = Get[String].unsafeGetNullable(rs, i + 1),
        name = Get[String].unsafeGetNullable(rs, i + 2)
      )
    )
  

}
