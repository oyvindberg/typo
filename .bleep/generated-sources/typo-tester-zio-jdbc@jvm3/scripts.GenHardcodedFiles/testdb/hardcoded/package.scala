/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb

package object hardcoded {
  implicit lazy val BigDecimalArrayDecoder: zio.jdbc.JdbcDecoder[scala.Array[java.math.BigDecimal]] = new zio.jdbc.JdbcDecoder[scala.Array[java.math.BigDecimal]] {
    override def unsafeDecode(columIndex: scala.Int, rs: java.sql.ResultSet): (scala.Int, scala.Array[java.math.BigDecimal]) = {
      val arr = rs.getArray(columIndex)
      if (arr eq null) columIndex -> null
      else {
        columIndex ->
          arr
            .getArray
            .asInstanceOf[Array[Any]]
            .foldLeft(Array.newBuilder[java.math.BigDecimal]) {
              case (b, x: java.math.BigDecimal) => b += x
              case (b, x: java.lang.Number) => b += x.asInstanceOf[java.math.BigDecimal]
              case (_, x) =>
                throw zio.jdbc.JdbcDecoderError(
                  message = s"Error decoding scala.Array(java.math.BigDecimal) from ResultSet",
                  cause = new IllegalStateException(
                    s"Retrieved ${x.getClass.getCanonicalName} type from JDBC array, but expected (java.math.BigDecimal). Re-check your decoder implementation"
                  ),
                  metadata = rs.getMetaData,
                  row = rs.getRow
                )
            }
            .result()
      }
    }
  }
  implicit lazy val BigDecimalArrayEncoder: zio.jdbc.JdbcEncoder[scala.Array[java.math.BigDecimal]] = zio.jdbc.JdbcEncoder.singleParamEncoder(BigDecimalArraySetter)
  implicit lazy val BigDecimalArraySetter: zio.jdbc.SqlFragment.Setter[scala.Array[java.math.BigDecimal]] = zio.jdbc.SqlFragment.Setter.forSqlType[scala.Array[java.math.BigDecimal]](
    (ps, i, v) => {
      ps.setArray(i, ps.getConnection.createArrayOf("numeric", v.map(x => x: scala.AnyRef)))
    },
    java.sql.Types.ARRAY
  )
  implicit lazy val BooleanArrayDecoder: zio.jdbc.JdbcDecoder[scala.Array[scala.Boolean]] = new zio.jdbc.JdbcDecoder[scala.Array[scala.Boolean]] {
    override def unsafeDecode(columIndex: scala.Int, rs: java.sql.ResultSet): (scala.Int, scala.Array[scala.Boolean]) = {
      val arr = rs.getArray(columIndex)
      if (arr eq null) columIndex -> null
      else {
        columIndex ->
          arr
            .getArray
            .asInstanceOf[Array[Any]]
            .foldLeft(Array.newBuilder[scala.Boolean]) {
              case (b, x: scala.Boolean) => b += x
              case (b, x: java.lang.Number) => b += x.asInstanceOf[scala.Boolean]
              case (_, x) =>
                throw zio.jdbc.JdbcDecoderError(
                  message = s"Error decoding scala.Array(scala.Boolean) from ResultSet",
                  cause = new IllegalStateException(
                    s"Retrieved ${x.getClass.getCanonicalName} type from JDBC array, but expected (scala.Boolean). Re-check your decoder implementation"
                  ),
                  metadata = rs.getMetaData,
                  row = rs.getRow
                )
            }
            .result()
      }
    }
  }
  implicit lazy val BooleanArrayEncoder: zio.jdbc.JdbcEncoder[scala.Array[scala.Boolean]] = zio.jdbc.JdbcEncoder.singleParamEncoder(BooleanArraySetter)
  implicit lazy val BooleanArraySetter: zio.jdbc.SqlFragment.Setter[scala.Array[scala.Boolean]] = zio.jdbc.SqlFragment.Setter.forSqlType[scala.Array[scala.Boolean]](
    (ps, i, v) => {
      ps.setArray(i, ps.getConnection.createArrayOf("bool", v.map(x => boolean2Boolean(x): scala.AnyRef)))
    },
    java.sql.Types.ARRAY
  )
  implicit lazy val DoubleArrayDecoder: zio.jdbc.JdbcDecoder[scala.Array[scala.Double]] = new zio.jdbc.JdbcDecoder[scala.Array[scala.Double]] {
    override def unsafeDecode(columIndex: scala.Int, rs: java.sql.ResultSet): (scala.Int, scala.Array[scala.Double]) = {
      val arr = rs.getArray(columIndex)
      if (arr eq null) columIndex -> null
      else {
        columIndex ->
          arr
            .getArray
            .asInstanceOf[Array[Any]]
            .foldLeft(Array.newBuilder[scala.Double]) {
              case (b, x: scala.Double) => b += x
              case (b, x: java.lang.Number) => b += x.asInstanceOf[scala.Double]
              case (_, x) =>
                throw zio.jdbc.JdbcDecoderError(
                  message = s"Error decoding scala.Array(scala.Double) from ResultSet",
                  cause = new IllegalStateException(
                    s"Retrieved ${x.getClass.getCanonicalName} type from JDBC array, but expected (scala.Double). Re-check your decoder implementation"
                  ),
                  metadata = rs.getMetaData,
                  row = rs.getRow
                )
            }
            .result()
      }
    }
  }
  implicit lazy val DoubleArrayEncoder: zio.jdbc.JdbcEncoder[scala.Array[scala.Double]] = zio.jdbc.JdbcEncoder.singleParamEncoder(DoubleArraySetter)
  implicit lazy val DoubleArraySetter: zio.jdbc.SqlFragment.Setter[scala.Array[scala.Double]] = zio.jdbc.SqlFragment.Setter.forSqlType[scala.Array[scala.Double]](
    (ps, i, v) => {
      ps.setArray(i, ps.getConnection.createArrayOf("float8", v.map(x => double2Double(x): scala.AnyRef)))
    },
    java.sql.Types.ARRAY
  )
  implicit lazy val FloatArrayDecoder: zio.jdbc.JdbcDecoder[scala.Array[scala.Float]] = new zio.jdbc.JdbcDecoder[scala.Array[scala.Float]] {
    override def unsafeDecode(columIndex: scala.Int, rs: java.sql.ResultSet): (scala.Int, scala.Array[scala.Float]) = {
      val arr = rs.getArray(columIndex)
      if (arr eq null) columIndex -> null
      else {
        columIndex ->
          arr
            .getArray
            .asInstanceOf[Array[Any]]
            .foldLeft(Array.newBuilder[scala.Float]) {
              case (b, x: scala.Float) => b += x
              case (b, x: java.lang.Number) => b += x.asInstanceOf[scala.Float]
              case (_, x) =>
                throw zio.jdbc.JdbcDecoderError(
                  message = s"Error decoding scala.Array(scala.Float) from ResultSet",
                  cause = new IllegalStateException(
                    s"Retrieved ${x.getClass.getCanonicalName} type from JDBC array, but expected (scala.Float). Re-check your decoder implementation"
                  ),
                  metadata = rs.getMetaData,
                  row = rs.getRow
                )
            }
            .result()
      }
    }
  }
  implicit lazy val FloatArrayEncoder: zio.jdbc.JdbcEncoder[scala.Array[scala.Float]] = zio.jdbc.JdbcEncoder.singleParamEncoder(FloatArraySetter)
  implicit lazy val FloatArraySetter: zio.jdbc.SqlFragment.Setter[scala.Array[scala.Float]] = zio.jdbc.SqlFragment.Setter.forSqlType[scala.Array[scala.Float]](
    (ps, i, v) => {
      ps.setArray(i, ps.getConnection.createArrayOf("float4", v.map(x => float2Float(x): scala.AnyRef)))
    },
    java.sql.Types.ARRAY
  )
  implicit lazy val IntArrayDecoder: zio.jdbc.JdbcDecoder[scala.Array[scala.Int]] = new zio.jdbc.JdbcDecoder[scala.Array[scala.Int]] {
    override def unsafeDecode(columIndex: scala.Int, rs: java.sql.ResultSet): (scala.Int, scala.Array[scala.Int]) = {
      val arr = rs.getArray(columIndex)
      if (arr eq null) columIndex -> null
      else {
        columIndex ->
          arr
            .getArray
            .asInstanceOf[Array[Any]]
            .foldLeft(Array.newBuilder[scala.Int]) {
              case (b, x: scala.Int) => b += x
              case (b, x: java.lang.Number) => b += x.asInstanceOf[scala.Int]
              case (_, x) =>
                throw zio.jdbc.JdbcDecoderError(
                  message = s"Error decoding scala.Array(scala.Int) from ResultSet",
                  cause = new IllegalStateException(
                    s"Retrieved ${x.getClass.getCanonicalName} type from JDBC array, but expected (scala.Int). Re-check your decoder implementation"
                  ),
                  metadata = rs.getMetaData,
                  row = rs.getRow
                )
            }
            .result()
      }
    }
  }
  implicit lazy val IntArrayEncoder: zio.jdbc.JdbcEncoder[scala.Array[scala.Int]] = zio.jdbc.JdbcEncoder.singleParamEncoder(IntArraySetter)
  implicit lazy val IntArraySetter: zio.jdbc.SqlFragment.Setter[scala.Array[scala.Int]] = zio.jdbc.SqlFragment.Setter.forSqlType[scala.Array[scala.Int]](
    (ps, i, v) => {
      ps.setArray(i, ps.getConnection.createArrayOf("int4", v.map(x => int2Integer(x): scala.AnyRef)))
    },
    java.sql.Types.ARRAY
  )
  implicit lazy val LongArrayDecoder: zio.jdbc.JdbcDecoder[scala.Array[scala.Long]] = new zio.jdbc.JdbcDecoder[scala.Array[scala.Long]] {
    override def unsafeDecode(columIndex: scala.Int, rs: java.sql.ResultSet): (scala.Int, scala.Array[scala.Long]) = {
      val arr = rs.getArray(columIndex)
      if (arr eq null) columIndex -> null
      else {
        columIndex ->
          arr
            .getArray
            .asInstanceOf[Array[Any]]
            .foldLeft(Array.newBuilder[scala.Long]) {
              case (b, x: scala.Long) => b += x
              case (b, x: java.lang.Number) => b += x.asInstanceOf[scala.Long]
              case (_, x) =>
                throw zio.jdbc.JdbcDecoderError(
                  message = s"Error decoding scala.Array(scala.Long) from ResultSet",
                  cause = new IllegalStateException(
                    s"Retrieved ${x.getClass.getCanonicalName} type from JDBC array, but expected (scala.Long). Re-check your decoder implementation"
                  ),
                  metadata = rs.getMetaData,
                  row = rs.getRow
                )
            }
            .result()
      }
    }
  }
  implicit lazy val LongArrayEncoder: zio.jdbc.JdbcEncoder[scala.Array[scala.Long]] = zio.jdbc.JdbcEncoder.singleParamEncoder(LongArraySetter)
  implicit lazy val LongArraySetter: zio.jdbc.SqlFragment.Setter[scala.Array[scala.Long]] = zio.jdbc.SqlFragment.Setter.forSqlType[scala.Array[scala.Long]](
    (ps, i, v) => {
      ps.setArray(i, ps.getConnection.createArrayOf("int8", v.map(x => long2Long(x): scala.AnyRef)))
    },
    java.sql.Types.ARRAY
  )
  implicit lazy val ScalaBigDecimalArrayDecoder: zio.jdbc.JdbcDecoder[scala.Array[scala.math.BigDecimal]] = BigDecimalArrayDecoder.map(v => if (v eq null) null else v.map(scala.math.BigDecimal.apply))
  implicit lazy val ScalaBigDecimalArrayEncoder: zio.jdbc.JdbcEncoder[scala.Array[scala.math.BigDecimal]] = BigDecimalArrayEncoder.contramap(_.map(_.bigDecimal))
  implicit lazy val ScalaBigDecimalArraySetter: zio.jdbc.SqlFragment.Setter[scala.Array[scala.math.BigDecimal]] = BigDecimalArraySetter.contramap(_.map(_.bigDecimal))
  implicit lazy val StringArrayDecoder: zio.jdbc.JdbcDecoder[scala.Array[java.lang.String]] = new zio.jdbc.JdbcDecoder[scala.Array[java.lang.String]] {
    override def unsafeDecode(columIndex: scala.Int, rs: java.sql.ResultSet): (scala.Int, scala.Array[java.lang.String]) = {
      val arr = rs.getArray(columIndex)
      if (arr eq null) columIndex -> null
      else {
        columIndex ->
          arr
            .getArray
            .asInstanceOf[Array[Any]]
            .foldLeft(Array.newBuilder[java.lang.String]) {
              case (b, x: java.lang.String) => b += x
              case (b, x: java.lang.Number) => b += x.asInstanceOf[java.lang.String]
              case (_, x) =>
                throw zio.jdbc.JdbcDecoderError(
                  message = s"Error decoding scala.Array(java.lang.String) from ResultSet",
                  cause = new IllegalStateException(
                    s"Retrieved ${x.getClass.getCanonicalName} type from JDBC array, but expected (java.lang.String). Re-check your decoder implementation"
                  ),
                  metadata = rs.getMetaData,
                  row = rs.getRow
                )
            }
            .result()
      }
    }
  }
  implicit lazy val StringArrayEncoder: zio.jdbc.JdbcEncoder[scala.Array[java.lang.String]] = zio.jdbc.JdbcEncoder.singleParamEncoder(StringArraySetter)
  implicit lazy val StringArraySetter: zio.jdbc.SqlFragment.Setter[scala.Array[java.lang.String]] = zio.jdbc.SqlFragment.Setter.forSqlType[scala.Array[java.lang.String]](
    (ps, i, v) => {
      ps.setArray(i, ps.getConnection.createArrayOf("varchar", v.map(x => x: scala.AnyRef)))
    },
    java.sql.Types.ARRAY
  )
  implicit def arrayParameterMetaData[T](implicit T: typo.dsl.ParameterMetaData[T]): typo.dsl.ParameterMetaData[scala.Array[T]] = new typo.dsl.ParameterMetaData[scala.Array[T]] {
    override def sqlType: java.lang.String = "_" + T.sqlType
    override def jdbcType: scala.Int = java.sql.Types.ARRAY
  }
}
