/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb.hardcoded.customtypes;

import scala.util.Success;
import scala.util.Try;
import testdb.hardcoded.Text;
import zio.json.JsonDecoder;
import zio.json.JsonEncoder;
import zio.json.JsonError;
import zio.json.internal.RetractReader;
import zio.json.internal.Write;

/** This signals a value where if you don't provide it, postgres will generate it for you */
sealed trait Defaulted[T] {
  def fold[U](onDefault: => U, onProvided: Function1[T, U]): U
  def getOrElse(onDefault: => T): T
}

object Defaulted {
  implicit def jsonDecoder[T](implicit T: JsonDecoder[T]): JsonDecoder[Defaulted[T]] = {
    new JsonDecoder[Defaulted[T]] {
      override def unsafeDecode(trace: List[JsonError], in: RetractReader): Defaulted[T] =
        Try(JsonDecoder.string.unsafeDecode(trace, in)) match {
          case Success("defaulted") => UseDefault()
          case _ => Provided(T.unsafeDecode(trace, in))
        }
      }
  }
  implicit def jsonEncoder[T](implicit T: JsonEncoder[T]): JsonEncoder[Defaulted[T]] = {
    new JsonEncoder[Defaulted[T]] {
      override def unsafeEncode(a: Defaulted[T], indent: Option[Int], out: Write): Unit =
        a match {
          case Provided(value) =>
            out.write("{")
            out.write("\"provided\":")
            T.unsafeEncode(value, None, out)
            out.write("}")
          case UseDefault() => out.write("\"defaulted\"")
        }
    }
  }
  implicit def text[T](implicit t: Text[T]): Text[Defaulted[T]] = {
    Text.instance {
      case (Defaulted.Provided(value), sb) => t.unsafeEncode(value, sb)
      case (Defaulted.UseDefault(), sb) =>
        sb.append("__DEFAULT_VALUE__")
        ()
    }
  }
  case class Provided[T](value: T) extends Defaulted[T] {
    def fold[U](onDefault: => U, onProvided: Function1[T, U]): U = onProvided(value)
    def getOrElse(onDefault: => T): T = value
  }
  case class UseDefault[T]() extends Defaulted[T] {
    def fold[U](onDefault: => U, onProvided: Function1[T, U]): U = onDefault
    def getOrElse(onDefault: => T): T = onDefault
  }
}