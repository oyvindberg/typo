/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb
package hardcoded



/** This is `Text` ported from doobie.
  *
  * It is used to encode rows in string format for the COPY command.
  *
  * The generic derivation part of the code is stripped, along with comments.
  */
trait Text[A] { outer =>
  def unsafeEncode(a: A, sb: StringBuilder): Unit
  def unsafeArrayEncode(a: A, sb: StringBuilder): Unit = unsafeEncode(a, sb)

  final def contramap[B](f: B => A): Text[B] =
    new Text[B] {
      override def unsafeArrayEncode(a: B, sb: StringBuilder): Unit = outer.unsafeArrayEncode(f(a), sb)
      override def unsafeEncode(a: B, sb: StringBuilder): Unit = outer.unsafeEncode(f(a), sb)
    }
}

object Text {
  def apply[A](implicit ev: Text[A]): ev.type = ev

  val DELIMETER: Char = '\t'
  val NULL: String = "\\N"

  def instance[A](f: (A, StringBuilder) => Unit): Text[A] = (sb, a) => f(sb, a)

  // String encoder escapes any embedded `QUOTE` characters.
  implicit val stringInstance: Text[String] =
    new Text[String] {
      // Standard char encodings that don't differ in array context
      def stdChar(c: Char, sb: StringBuilder): StringBuilder =
        c match {
          case '\b' => sb.append("\\b")
          case '\f' => sb.append("\\f")
          case '\n' => sb.append("\\n")
          case '\r' => sb.append("\\r")
          case '\t' => sb.append("\\t")
          case 0x0b => sb.append("\\v")
          case c    => sb.append(c)
        }

      def unsafeEncode(s: String, sb: StringBuilder): Unit =
        s.foreach {
          case '\\' => sb.append("\\\\") // backslash must be doubled
          case c    => stdChar(c, sb)
        }

      // I am not confident about this encoder. Postgres seems not to be able to cope with low
      // control characters or high whitespace characters so these are simply filtered out in the
      // tests. It should accommodate arrays of non-pathological strings but it would be nice to
      // have a complete specification of what's actually happening.
      override def unsafeArrayEncode(s: String, sb: StringBuilder): Unit = {
        sb.append('"')
        s.foreach {
          case '\"' => sb.append("\\\\\"")
          case '\\' => sb.append("\\\\\\\\") // srsly
          case c    => stdChar(c, sb)
        }
        sb.append('"')
        ()
      }
    }

  implicit val charInstance: Text[Char] = instance { (n, sb) => sb.append(n.toString); () }
  implicit val intInstance: Text[Int] = instance { (n, sb) => sb.append(n); () }
  implicit val shortInstance: Text[Short] = instance { (n, sb) => sb.append(n); () }
  implicit val longInstance: Text[Long] = instance { (n, sb) => sb.append(n); () }
  implicit val floatInstance: Text[Float] = instance { (n, sb) => sb.append(n); () }
  implicit val doubleInstance: Text[Double] = instance { (n, sb) => sb.append(n); () }
  implicit val bigDecimalInstance: Text[BigDecimal] = instance { (n, sb) => sb.append(n); () }
  implicit val booleanInstance: Text[Boolean] = instance { (n, sb) => sb.append(n); () }
  implicit val byteArrayInstance: Text[Array[Byte]] = instance { (bs, sb) =>
    sb.append("\\\\x")
    if (bs.length > 0) {
      val hex = BigInt(1, bs).toString(16)
      val pad = bs.length * 2 - hex.length
      0.until(pad).foreach { _ => sb.append("0") }
      sb.append(hex)
      ()
    }
  }

  implicit def option[A](implicit A: Text[A]): Text[Option[A]] = instance {
    case (Some(a), sb) => A.unsafeEncode(a, sb)
    case (None, sb) =>
      sb.append(Text.NULL)
      ()
  }
  implicit def iterableInstance[F[_], A](implicit ev: Text[A], f: F[A] => Iterable[A]): Text[F[A]] = instance { (as, sb) =>
    var first = true
    sb.append("{")
    f(as).foreach { a =>
      if (first) first = false
      else sb.append(',')
      ev.unsafeArrayEncode(a, sb)
    }
    sb.append('}')
    ()
  }
}
