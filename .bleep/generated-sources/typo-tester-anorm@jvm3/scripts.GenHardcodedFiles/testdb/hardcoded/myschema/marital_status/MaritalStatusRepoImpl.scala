/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb.hardcoded.myschema.marital_status;

import anorm.BatchSql;
import anorm.NamedParameter;
import anorm.ParameterValue;
import anorm.RowParser;
import anorm.SQL;
import anorm.SimpleSql;
import anorm.SqlStringInterpolation;
import java.sql.Connection;
import scala.annotation.nowarn;
import testdb.hardcoded.streamingInsert;
import typo.dsl.DeleteBuilder;
import typo.dsl.SelectBuilder;
import typo.dsl.SelectBuilderSql;
import typo.dsl.UpdateBuilder;

class MaritalStatusRepoImpl extends MaritalStatusRepo {
  def delete: DeleteBuilder[MaritalStatusFields, MaritalStatusRow] = DeleteBuilder("myschema.marital_status", MaritalStatusFields.structure)
  def deleteById(id: MaritalStatusId)(implicit c: Connection): Boolean = SQL"""delete from myschema.marital_status where "id" = ${ParameterValue(id, null, MaritalStatusId.toStatement)}""".executeUpdate() > 0
  def deleteByIds(ids: Array[MaritalStatusId])(implicit c: Connection): Int = {
    SQL"""delete
          from myschema.marital_status
          where "id" = ANY(${ParameterValue(ids, null, MaritalStatusId.arrayToStatement)})
       """.executeUpdate()
  
  }
  def insert(unsaved: MaritalStatusRow)(implicit c: Connection): MaritalStatusRow = {
    SQL"""insert into myschema.marital_status("id")
           values (${ParameterValue(unsaved.id, null, MaritalStatusId.toStatement)}::int8)
           returning "id"
        """
      .executeInsert(MaritalStatusRow.rowParser(1).single)
  
  }
  def insertStreaming(unsaved: Iterator[MaritalStatusRow], batchSize: Int = 10000)(implicit c: Connection): Long = streamingInsert(s"""COPY myschema.marital_status("id") FROM STDIN""", batchSize, unsaved)(MaritalStatusRow.text, c)
  def select: SelectBuilder[MaritalStatusFields, MaritalStatusRow] = SelectBuilderSql("myschema.marital_status", MaritalStatusFields.structure, MaritalStatusRow.rowParser)
  def selectAll(implicit c: Connection): List[MaritalStatusRow] = {
    SQL"""select "id"
          from myschema.marital_status
       """.as(MaritalStatusRow.rowParser(1).*)
  }
  def selectByFieldValues(fieldValues: List[MaritalStatusFieldValue[?]])(implicit c: Connection): List[MaritalStatusRow] = {
    fieldValues match {
      case Nil => selectAll
      case nonEmpty =>
        val namedParameters = nonEmpty.map{
          case MaritalStatusFieldValue.id(value) => NamedParameter("id", ParameterValue(value, null, MaritalStatusId.toStatement))
        }
        val quote = '"'.toString
        val q = s"""select "id"
                    from myschema.marital_status
                    where ${namedParameters.map(x => s"$quote${x.name}$quote = {${x.name}}").mkString(" AND ")}
                 """
        SimpleSql(SQL(q), namedParameters.map(_.tupled).toMap, RowParser.successful)
          .as(MaritalStatusRow.rowParser(1).*)
    }
  
  }
  def selectById(id: MaritalStatusId)(implicit c: Connection): Option[MaritalStatusRow] = {
    SQL"""select "id"
          from myschema.marital_status
          where "id" = ${ParameterValue(id, null, MaritalStatusId.toStatement)}
       """.as(MaritalStatusRow.rowParser(1).singleOpt)
  }
  def selectByIds(ids: Array[MaritalStatusId])(implicit c: Connection): List[MaritalStatusRow] = {
    SQL"""select "id"
          from myschema.marital_status
          where "id" = ANY(${ParameterValue(ids, null, MaritalStatusId.arrayToStatement)})
       """.as(MaritalStatusRow.rowParser(1).*)
  
  }
  def selectByIdsTracked(ids: Array[MaritalStatusId])(implicit c: Connection): Map[MaritalStatusId, MaritalStatusRow] = {
    val byId = selectByIds(ids).view.map(x => (x.id, x)).toMap
    ids.view.flatMap(id => byId.get(id).map(x => (id, x))).toMap
  }
  def update: UpdateBuilder[MaritalStatusFields, MaritalStatusRow] = UpdateBuilder("myschema.marital_status", MaritalStatusFields.structure, MaritalStatusRow.rowParser)
  def updateFieldValues(id: MaritalStatusId, fieldValues: List[MaritalStatusFieldValue[?]])(implicit c: Connection): Boolean = {
    fieldValues match {
      case Nil => false
      case nonEmpty =>
        val namedParameters = nonEmpty.map{
          case MaritalStatusFieldValue.id(value) => NamedParameter("id", ParameterValue(value, null, MaritalStatusId.toStatement))
        }
        val quote = '"'.toString
        val q = s"""update myschema.marital_status
                    set ${namedParameters.map(x => s"$quote${x.name}$quote = {${x.name}}").mkString(", ")}
                    where "id" = {id}
                 """
        SimpleSql(SQL(q), namedParameters.map(_.tupled).toMap ++ List(("id", ParameterValue(id, null, MaritalStatusId.toStatement))), RowParser.successful)
          .executeUpdate() > 0
    }
  
  }
  def upsert(unsaved: MaritalStatusRow)(implicit c: Connection): MaritalStatusRow = {
    SQL"""insert into myschema.marital_status("id")
           values (
             ${ParameterValue(unsaved.id, null, MaritalStatusId.toStatement)}::int8
           )
           on conflict ("id")
           do nothing
           returning "id"
        """
      .executeInsert(MaritalStatusRow.rowParser(1).single)
  
  }
  def upsertBatch(unsaved: Iterable[MaritalStatusRow])(implicit c: Connection): List[MaritalStatusRow] = {
    def toNamedParameter(row: MaritalStatusRow): List[NamedParameter] = List(
      NamedParameter("id", ParameterValue(row.id, null, MaritalStatusId.toStatement))
    )
    unsaved.toList match {
      case Nil => Nil
      case head :: rest =>
        new anorm.testdb.hardcoded.ExecuteReturningSyntax.Ops(
          BatchSql(
            s"""insert into myschema.marital_status("id")
                values ({id}::int8)
                on conflict ("id")
                do nothing
                returning "id"
             """,
            toNamedParameter(head),
            rest.map(toNamedParameter)*
          )
        ).executeReturning(MaritalStatusRow.rowParser(1).*)
    }
  }
  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  def upsertStreaming(unsaved: Iterator[MaritalStatusRow], batchSize: Int = 10000)(implicit c: Connection): Int = {
    SQL"create temporary table marital_status_TEMP (like myschema.marital_status) on commit drop".execute(): @nowarn
    streamingInsert(s"""copy marital_status_TEMP("id") from stdin""", batchSize, unsaved)(MaritalStatusRow.text, c): @nowarn
    SQL"""insert into myschema.marital_status("id")
          select * from marital_status_TEMP
          on conflict ("id")
          do nothing
          ;
          drop table marital_status_TEMP;""".executeUpdate()
  }
}