/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb
package hardcoded
package myschema
package person

import doobie.free.connection.ConnectionIO
import doobie.syntax.string.toSqlInterpolator
import doobie.util.fragment.Fragment
import fs2.Stream
import testdb.hardcoded.Defaulted
import testdb.hardcoded.myschema.Sector
import testdb.hardcoded.myschema.marital_status.MaritalStatusId

object PersonRepoImpl extends PersonRepo {
  override def delete(id: PersonId): ConnectionIO[Boolean] = {
    sql"""delete from myschema.person where "id" = ${id}""".update.run.map(_ > 0)
  }
  override def insert(unsaved: PersonRow): ConnectionIO[PersonRow] = {
    sql"""insert into myschema.person("id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector)
          values (${unsaved.id}::int8, ${unsaved.favouriteFootballClubId}, ${unsaved.name}, ${unsaved.nickName}, ${unsaved.blogUrl}, ${unsaved.email}, ${unsaved.phone}, ${unsaved.likesPizza}, ${unsaved.maritalStatusId}, ${unsaved.workEmail}, ${unsaved.sector}::myschema.sector)
          returning "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector
       """.query[PersonRow].unique
  }
  override def insert(unsaved: PersonRowUnsaved): ConnectionIO[PersonRow] = {
    val fs = List(
      Some((Fragment.const(s"favourite_football_club_id"), fr"${unsaved.favouriteFootballClubId}")),
      Some((Fragment.const(s""""name""""), fr"${unsaved.name}")),
      Some((Fragment.const(s"nick_name"), fr"${unsaved.nickName}")),
      Some((Fragment.const(s"blog_url"), fr"${unsaved.blogUrl}")),
      Some((Fragment.const(s"email"), fr"${unsaved.email}")),
      Some((Fragment.const(s"phone"), fr"${unsaved.phone}")),
      Some((Fragment.const(s"likes_pizza"), fr"${unsaved.likesPizza}")),
      Some((Fragment.const(s"work_email"), fr"${unsaved.workEmail}")),
      unsaved.id match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s""""id""""), fr"${value: PersonId}::int8"))
      },
      unsaved.maritalStatusId match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"marital_status_id"), fr"${value: MaritalStatusId}"))
      },
      unsaved.sector match {
        case Defaulted.UseDefault => None
        case Defaulted.Provided(value) => Some((Fragment.const(s"sector"), fr"${value: Sector}::myschema.sector"))
      }
    ).flatten
    
    val q = if (fs.isEmpty) {
      sql"""insert into myschema.person default values
            returning "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector
         """
    } else {
      import cats.syntax.foldable.toFoldableOps
      sql"""insert into myschema.person(${fs.map { case (n, _) => n }.intercalate(fr", ")})
            values (${fs.map { case (_, f) => f }.intercalate(fr", ")})
            returning "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector
         """
    }
    q.query[PersonRow].unique
  
  }
  override def selectAll: Stream[ConnectionIO, PersonRow] = {
    sql"""select "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector from myschema.person""".query[PersonRow].stream
  }
  override def selectById(id: PersonId): ConnectionIO[Option[PersonRow]] = {
    sql"""select "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector from myschema.person where "id" = ${id}""".query[PersonRow].option
  }
  override def selectByIds(ids: Array[PersonId]): Stream[ConnectionIO, PersonRow] = {
    sql"""select "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector from myschema.person where "id" = ANY(${ids})""".query[PersonRow].stream
  }
  override def update(row: PersonRow): ConnectionIO[Boolean] = {
    val id = row.id
    sql"""update myschema.person
          set favourite_football_club_id = ${row.favouriteFootballClubId},
              "name" = ${row.name},
              nick_name = ${row.nickName},
              blog_url = ${row.blogUrl},
              email = ${row.email},
              phone = ${row.phone},
              likes_pizza = ${row.likesPizza},
              marital_status_id = ${row.maritalStatusId},
              work_email = ${row.workEmail},
              sector = ${row.sector}::myschema.sector
          where "id" = ${id}
       """
      .update
      .run
      .map(_ > 0)
  }
  override def upsert(unsaved: PersonRow): ConnectionIO[PersonRow] = {
    sql"""insert into myschema.person("id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector)
          values (
            ${unsaved.id}::int8,
            ${unsaved.favouriteFootballClubId},
            ${unsaved.name},
            ${unsaved.nickName},
            ${unsaved.blogUrl},
            ${unsaved.email},
            ${unsaved.phone},
            ${unsaved.likesPizza},
            ${unsaved.maritalStatusId},
            ${unsaved.workEmail},
            ${unsaved.sector}::myschema.sector
          )
          on conflict ("id")
          do update set
            favourite_football_club_id = EXCLUDED.favourite_football_club_id,
            "name" = EXCLUDED."name",
            nick_name = EXCLUDED.nick_name,
            blog_url = EXCLUDED.blog_url,
            email = EXCLUDED.email,
            phone = EXCLUDED.phone,
            likes_pizza = EXCLUDED.likes_pizza,
            marital_status_id = EXCLUDED.marital_status_id,
            work_email = EXCLUDED.work_email,
            sector = EXCLUDED.sector
          returning "id", favourite_football_club_id, "name", nick_name, blog_url, email, phone, likes_pizza, marital_status_id, work_email, sector
       """.query[PersonRow].unique
  }
}
